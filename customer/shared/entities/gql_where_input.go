// Code generated by ent, DO NOT EDIT.

package entities

import (
	"errors"
	"fmt"
	"time"

	"github.com/sigmasee/sigmasee/customer/shared/entities/customer"
	"github.com/sigmasee/sigmasee/customer/shared/entities/customeroutbox"
	"github.com/sigmasee/sigmasee/customer/shared/entities/customersetting"
	"github.com/sigmasee/sigmasee/customer/shared/entities/identity"
	"github.com/sigmasee/sigmasee/customer/shared/entities/predicate"
)

// CustomerWhereInput represents a where input for filtering Customer queries.
type CustomerWhereInput struct {
	Predicates []predicate.Customer  `json:"-"`
	Not        *CustomerWhereInput   `json:"not,omitempty"`
	Or         []*CustomerWhereInput `json:"or,omitempty"`
	And        []*CustomerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "designation" field predicates.
	Designation             *string  `json:"designation,omitempty"`
	DesignationNEQ          *string  `json:"designationNEQ,omitempty"`
	DesignationIn           []string `json:"designationIn,omitempty"`
	DesignationNotIn        []string `json:"designationNotIn,omitempty"`
	DesignationGT           *string  `json:"designationGT,omitempty"`
	DesignationGTE          *string  `json:"designationGTE,omitempty"`
	DesignationLT           *string  `json:"designationLT,omitempty"`
	DesignationLTE          *string  `json:"designationLTE,omitempty"`
	DesignationContains     *string  `json:"designationContains,omitempty"`
	DesignationHasPrefix    *string  `json:"designationHasPrefix,omitempty"`
	DesignationHasSuffix    *string  `json:"designationHasSuffix,omitempty"`
	DesignationIsNil        bool     `json:"designationIsNil,omitempty"`
	DesignationNotNil       bool     `json:"designationNotNil,omitempty"`
	DesignationEqualFold    *string  `json:"designationEqualFold,omitempty"`
	DesignationContainsFold *string  `json:"designationContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        bool     `json:"titleIsNil,omitempty"`
	TitleNotNil       bool     `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "given_name" field predicates.
	GivenName             *string  `json:"givenName,omitempty"`
	GivenNameNEQ          *string  `json:"givenNameNEQ,omitempty"`
	GivenNameIn           []string `json:"givenNameIn,omitempty"`
	GivenNameNotIn        []string `json:"givenNameNotIn,omitempty"`
	GivenNameGT           *string  `json:"givenNameGT,omitempty"`
	GivenNameGTE          *string  `json:"givenNameGTE,omitempty"`
	GivenNameLT           *string  `json:"givenNameLT,omitempty"`
	GivenNameLTE          *string  `json:"givenNameLTE,omitempty"`
	GivenNameContains     *string  `json:"givenNameContains,omitempty"`
	GivenNameHasPrefix    *string  `json:"givenNameHasPrefix,omitempty"`
	GivenNameHasSuffix    *string  `json:"givenNameHasSuffix,omitempty"`
	GivenNameIsNil        bool     `json:"givenNameIsNil,omitempty"`
	GivenNameNotNil       bool     `json:"givenNameNotNil,omitempty"`
	GivenNameEqualFold    *string  `json:"givenNameEqualFold,omitempty"`
	GivenNameContainsFold *string  `json:"givenNameContainsFold,omitempty"`

	// "middle_name" field predicates.
	MiddleName             *string  `json:"middleName,omitempty"`
	MiddleNameNEQ          *string  `json:"middleNameNEQ,omitempty"`
	MiddleNameIn           []string `json:"middleNameIn,omitempty"`
	MiddleNameNotIn        []string `json:"middleNameNotIn,omitempty"`
	MiddleNameGT           *string  `json:"middleNameGT,omitempty"`
	MiddleNameGTE          *string  `json:"middleNameGTE,omitempty"`
	MiddleNameLT           *string  `json:"middleNameLT,omitempty"`
	MiddleNameLTE          *string  `json:"middleNameLTE,omitempty"`
	MiddleNameContains     *string  `json:"middleNameContains,omitempty"`
	MiddleNameHasPrefix    *string  `json:"middleNameHasPrefix,omitempty"`
	MiddleNameHasSuffix    *string  `json:"middleNameHasSuffix,omitempty"`
	MiddleNameIsNil        bool     `json:"middleNameIsNil,omitempty"`
	MiddleNameNotNil       bool     `json:"middleNameNotNil,omitempty"`
	MiddleNameEqualFold    *string  `json:"middleNameEqualFold,omitempty"`
	MiddleNameContainsFold *string  `json:"middleNameContainsFold,omitempty"`

	// "family_name" field predicates.
	FamilyName             *string  `json:"familyName,omitempty"`
	FamilyNameNEQ          *string  `json:"familyNameNEQ,omitempty"`
	FamilyNameIn           []string `json:"familyNameIn,omitempty"`
	FamilyNameNotIn        []string `json:"familyNameNotIn,omitempty"`
	FamilyNameGT           *string  `json:"familyNameGT,omitempty"`
	FamilyNameGTE          *string  `json:"familyNameGTE,omitempty"`
	FamilyNameLT           *string  `json:"familyNameLT,omitempty"`
	FamilyNameLTE          *string  `json:"familyNameLTE,omitempty"`
	FamilyNameContains     *string  `json:"familyNameContains,omitempty"`
	FamilyNameHasPrefix    *string  `json:"familyNameHasPrefix,omitempty"`
	FamilyNameHasSuffix    *string  `json:"familyNameHasSuffix,omitempty"`
	FamilyNameIsNil        bool     `json:"familyNameIsNil,omitempty"`
	FamilyNameNotNil       bool     `json:"familyNameNotNil,omitempty"`
	FamilyNameEqualFold    *string  `json:"familyNameEqualFold,omitempty"`
	FamilyNameContainsFold *string  `json:"familyNameContainsFold,omitempty"`

	// "photo_url" field predicates.
	PhotoURL             *string  `json:"photoURL,omitempty"`
	PhotoURLNEQ          *string  `json:"photoURLNEQ,omitempty"`
	PhotoURLIn           []string `json:"photoURLIn,omitempty"`
	PhotoURLNotIn        []string `json:"photoURLNotIn,omitempty"`
	PhotoURLGT           *string  `json:"photoURLGT,omitempty"`
	PhotoURLGTE          *string  `json:"photoURLGTE,omitempty"`
	PhotoURLLT           *string  `json:"photoURLLT,omitempty"`
	PhotoURLLTE          *string  `json:"photoURLLTE,omitempty"`
	PhotoURLContains     *string  `json:"photoURLContains,omitempty"`
	PhotoURLHasPrefix    *string  `json:"photoURLHasPrefix,omitempty"`
	PhotoURLHasSuffix    *string  `json:"photoURLHasSuffix,omitempty"`
	PhotoURLIsNil        bool     `json:"photoURLIsNil,omitempty"`
	PhotoURLNotNil       bool     `json:"photoURLNotNil,omitempty"`
	PhotoURLEqualFold    *string  `json:"photoURLEqualFold,omitempty"`
	PhotoURLContainsFold *string  `json:"photoURLContainsFold,omitempty"`

	// "photo_url_24" field predicates.
	PhotoURL24             *string  `json:"photoURL24,omitempty"`
	PhotoURL24NEQ          *string  `json:"photoURL24NEQ,omitempty"`
	PhotoURL24In           []string `json:"photoURL24In,omitempty"`
	PhotoURL24NotIn        []string `json:"photoURL24NotIn,omitempty"`
	PhotoURL24GT           *string  `json:"photoURL24GT,omitempty"`
	PhotoURL24GTE          *string  `json:"photoURL24GTE,omitempty"`
	PhotoURL24LT           *string  `json:"photoURL24LT,omitempty"`
	PhotoURL24LTE          *string  `json:"photoURL24LTE,omitempty"`
	PhotoURL24Contains     *string  `json:"photoURL24Contains,omitempty"`
	PhotoURL24HasPrefix    *string  `json:"photoURL24HasPrefix,omitempty"`
	PhotoURL24HasSuffix    *string  `json:"photoURL24HasSuffix,omitempty"`
	PhotoURL24IsNil        bool     `json:"photoURL24IsNil,omitempty"`
	PhotoURL24NotNil       bool     `json:"photoURL24NotNil,omitempty"`
	PhotoURL24EqualFold    *string  `json:"photoURL24EqualFold,omitempty"`
	PhotoURL24ContainsFold *string  `json:"photoURL24ContainsFold,omitempty"`

	// "photo_url_32" field predicates.
	PhotoURL32             *string  `json:"photoURL32,omitempty"`
	PhotoURL32NEQ          *string  `json:"photoURL32NEQ,omitempty"`
	PhotoURL32In           []string `json:"photoURL32In,omitempty"`
	PhotoURL32NotIn        []string `json:"photoURL32NotIn,omitempty"`
	PhotoURL32GT           *string  `json:"photoURL32GT,omitempty"`
	PhotoURL32GTE          *string  `json:"photoURL32GTE,omitempty"`
	PhotoURL32LT           *string  `json:"photoURL32LT,omitempty"`
	PhotoURL32LTE          *string  `json:"photoURL32LTE,omitempty"`
	PhotoURL32Contains     *string  `json:"photoURL32Contains,omitempty"`
	PhotoURL32HasPrefix    *string  `json:"photoURL32HasPrefix,omitempty"`
	PhotoURL32HasSuffix    *string  `json:"photoURL32HasSuffix,omitempty"`
	PhotoURL32IsNil        bool     `json:"photoURL32IsNil,omitempty"`
	PhotoURL32NotNil       bool     `json:"photoURL32NotNil,omitempty"`
	PhotoURL32EqualFold    *string  `json:"photoURL32EqualFold,omitempty"`
	PhotoURL32ContainsFold *string  `json:"photoURL32ContainsFold,omitempty"`

	// "photo_url_48" field predicates.
	PhotoURL48             *string  `json:"photoURL48,omitempty"`
	PhotoURL48NEQ          *string  `json:"photoURL48NEQ,omitempty"`
	PhotoURL48In           []string `json:"photoURL48In,omitempty"`
	PhotoURL48NotIn        []string `json:"photoURL48NotIn,omitempty"`
	PhotoURL48GT           *string  `json:"photoURL48GT,omitempty"`
	PhotoURL48GTE          *string  `json:"photoURL48GTE,omitempty"`
	PhotoURL48LT           *string  `json:"photoURL48LT,omitempty"`
	PhotoURL48LTE          *string  `json:"photoURL48LTE,omitempty"`
	PhotoURL48Contains     *string  `json:"photoURL48Contains,omitempty"`
	PhotoURL48HasPrefix    *string  `json:"photoURL48HasPrefix,omitempty"`
	PhotoURL48HasSuffix    *string  `json:"photoURL48HasSuffix,omitempty"`
	PhotoURL48IsNil        bool     `json:"photoURL48IsNil,omitempty"`
	PhotoURL48NotNil       bool     `json:"photoURL48NotNil,omitempty"`
	PhotoURL48EqualFold    *string  `json:"photoURL48EqualFold,omitempty"`
	PhotoURL48ContainsFold *string  `json:"photoURL48ContainsFold,omitempty"`

	// "photo_url_72" field predicates.
	PhotoURL72             *string  `json:"photoURL72,omitempty"`
	PhotoURL72NEQ          *string  `json:"photoURL72NEQ,omitempty"`
	PhotoURL72In           []string `json:"photoURL72In,omitempty"`
	PhotoURL72NotIn        []string `json:"photoURL72NotIn,omitempty"`
	PhotoURL72GT           *string  `json:"photoURL72GT,omitempty"`
	PhotoURL72GTE          *string  `json:"photoURL72GTE,omitempty"`
	PhotoURL72LT           *string  `json:"photoURL72LT,omitempty"`
	PhotoURL72LTE          *string  `json:"photoURL72LTE,omitempty"`
	PhotoURL72Contains     *string  `json:"photoURL72Contains,omitempty"`
	PhotoURL72HasPrefix    *string  `json:"photoURL72HasPrefix,omitempty"`
	PhotoURL72HasSuffix    *string  `json:"photoURL72HasSuffix,omitempty"`
	PhotoURL72IsNil        bool     `json:"photoURL72IsNil,omitempty"`
	PhotoURL72NotNil       bool     `json:"photoURL72NotNil,omitempty"`
	PhotoURL72EqualFold    *string  `json:"photoURL72EqualFold,omitempty"`
	PhotoURL72ContainsFold *string  `json:"photoURL72ContainsFold,omitempty"`

	// "photo_url_192" field predicates.
	PhotoURL192             *string  `json:"photoURL192,omitempty"`
	PhotoURL192NEQ          *string  `json:"photoURL192NEQ,omitempty"`
	PhotoURL192In           []string `json:"photoURL192In,omitempty"`
	PhotoURL192NotIn        []string `json:"photoURL192NotIn,omitempty"`
	PhotoURL192GT           *string  `json:"photoURL192GT,omitempty"`
	PhotoURL192GTE          *string  `json:"photoURL192GTE,omitempty"`
	PhotoURL192LT           *string  `json:"photoURL192LT,omitempty"`
	PhotoURL192LTE          *string  `json:"photoURL192LTE,omitempty"`
	PhotoURL192Contains     *string  `json:"photoURL192Contains,omitempty"`
	PhotoURL192HasPrefix    *string  `json:"photoURL192HasPrefix,omitempty"`
	PhotoURL192HasSuffix    *string  `json:"photoURL192HasSuffix,omitempty"`
	PhotoURL192IsNil        bool     `json:"photoURL192IsNil,omitempty"`
	PhotoURL192NotNil       bool     `json:"photoURL192NotNil,omitempty"`
	PhotoURL192EqualFold    *string  `json:"photoURL192EqualFold,omitempty"`
	PhotoURL192ContainsFold *string  `json:"photoURL192ContainsFold,omitempty"`

	// "photo_url_512" field predicates.
	PhotoURL512             *string  `json:"photoURL512,omitempty"`
	PhotoURL512NEQ          *string  `json:"photoURL512NEQ,omitempty"`
	PhotoURL512In           []string `json:"photoURL512In,omitempty"`
	PhotoURL512NotIn        []string `json:"photoURL512NotIn,omitempty"`
	PhotoURL512GT           *string  `json:"photoURL512GT,omitempty"`
	PhotoURL512GTE          *string  `json:"photoURL512GTE,omitempty"`
	PhotoURL512LT           *string  `json:"photoURL512LT,omitempty"`
	PhotoURL512LTE          *string  `json:"photoURL512LTE,omitempty"`
	PhotoURL512Contains     *string  `json:"photoURL512Contains,omitempty"`
	PhotoURL512HasPrefix    *string  `json:"photoURL512HasPrefix,omitempty"`
	PhotoURL512HasSuffix    *string  `json:"photoURL512HasSuffix,omitempty"`
	PhotoURL512IsNil        bool     `json:"photoURL512IsNil,omitempty"`
	PhotoURL512NotNil       bool     `json:"photoURL512NotNil,omitempty"`
	PhotoURL512EqualFold    *string  `json:"photoURL512EqualFold,omitempty"`
	PhotoURL512ContainsFold *string  `json:"photoURL512ContainsFold,omitempty"`

	// "timezone" field predicates.
	Timezone             *string  `json:"timezone,omitempty"`
	TimezoneNEQ          *string  `json:"timezoneNEQ,omitempty"`
	TimezoneIn           []string `json:"timezoneIn,omitempty"`
	TimezoneNotIn        []string `json:"timezoneNotIn,omitempty"`
	TimezoneGT           *string  `json:"timezoneGT,omitempty"`
	TimezoneGTE          *string  `json:"timezoneGTE,omitempty"`
	TimezoneLT           *string  `json:"timezoneLT,omitempty"`
	TimezoneLTE          *string  `json:"timezoneLTE,omitempty"`
	TimezoneContains     *string  `json:"timezoneContains,omitempty"`
	TimezoneHasPrefix    *string  `json:"timezoneHasPrefix,omitempty"`
	TimezoneHasSuffix    *string  `json:"timezoneHasSuffix,omitempty"`
	TimezoneIsNil        bool     `json:"timezoneIsNil,omitempty"`
	TimezoneNotNil       bool     `json:"timezoneNotNil,omitempty"`
	TimezoneEqualFold    *string  `json:"timezoneEqualFold,omitempty"`
	TimezoneContainsFold *string  `json:"timezoneContainsFold,omitempty"`

	// "locale" field predicates.
	Locale             *string  `json:"locale,omitempty"`
	LocaleNEQ          *string  `json:"localeNEQ,omitempty"`
	LocaleIn           []string `json:"localeIn,omitempty"`
	LocaleNotIn        []string `json:"localeNotIn,omitempty"`
	LocaleGT           *string  `json:"localeGT,omitempty"`
	LocaleGTE          *string  `json:"localeGTE,omitempty"`
	LocaleLT           *string  `json:"localeLT,omitempty"`
	LocaleLTE          *string  `json:"localeLTE,omitempty"`
	LocaleContains     *string  `json:"localeContains,omitempty"`
	LocaleHasPrefix    *string  `json:"localeHasPrefix,omitempty"`
	LocaleHasSuffix    *string  `json:"localeHasSuffix,omitempty"`
	LocaleIsNil        bool     `json:"localeIsNil,omitempty"`
	LocaleNotNil       bool     `json:"localeNotNil,omitempty"`
	LocaleEqualFold    *string  `json:"localeEqualFold,omitempty"`
	LocaleContainsFold *string  `json:"localeContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "modified_at" field predicates.
	ModifiedAt       *time.Time  `json:"modifiedAt,omitempty"`
	ModifiedAtNEQ    *time.Time  `json:"modifiedAtNEQ,omitempty"`
	ModifiedAtIn     []time.Time `json:"modifiedAtIn,omitempty"`
	ModifiedAtNotIn  []time.Time `json:"modifiedAtNotIn,omitempty"`
	ModifiedAtGT     *time.Time  `json:"modifiedAtGT,omitempty"`
	ModifiedAtGTE    *time.Time  `json:"modifiedAtGTE,omitempty"`
	ModifiedAtLT     *time.Time  `json:"modifiedAtLT,omitempty"`
	ModifiedAtLTE    *time.Time  `json:"modifiedAtLTE,omitempty"`
	ModifiedAtIsNil  bool        `json:"modifiedAtIsNil,omitempty"`
	ModifiedAtNotNil bool        `json:"modifiedAtNotNil,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "identities" edge predicates.
	HasIdentities     *bool                 `json:"hasIdentities,omitempty"`
	HasIdentitiesWith []*IdentityWhereInput `json:"hasIdentitiesWith,omitempty"`

	// "customer_settings" edge predicates.
	HasCustomerSettings     *bool                        `json:"hasCustomerSettings,omitempty"`
	HasCustomerSettingsWith []*CustomerSettingWhereInput `json:"hasCustomerSettingsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CustomerWhereInput) AddPredicates(predicates ...predicate.Customer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CustomerWhereInput filter on the CustomerQuery builder.
func (i *CustomerWhereInput) Filter(q *CustomerQuery) (*CustomerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCustomerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCustomerWhereInput is returned in case the CustomerWhereInput is empty.
var ErrEmptyCustomerWhereInput = errors.New("entities: empty predicate CustomerWhereInput")

// P returns a predicate for filtering customers.
// An error is returned if the input is empty or invalid.
func (i *CustomerWhereInput) P() (predicate.Customer, error) {
	var predicates []predicate.Customer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, customer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Customer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, customer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Customer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, customer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, customer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, customer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, customer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, customer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, customer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, customer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, customer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, customer.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, customer.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, customer.IDContainsFold(*i.IDContainsFold))
	}
	if i.Designation != nil {
		predicates = append(predicates, customer.DesignationEQ(*i.Designation))
	}
	if i.DesignationNEQ != nil {
		predicates = append(predicates, customer.DesignationNEQ(*i.DesignationNEQ))
	}
	if len(i.DesignationIn) > 0 {
		predicates = append(predicates, customer.DesignationIn(i.DesignationIn...))
	}
	if len(i.DesignationNotIn) > 0 {
		predicates = append(predicates, customer.DesignationNotIn(i.DesignationNotIn...))
	}
	if i.DesignationGT != nil {
		predicates = append(predicates, customer.DesignationGT(*i.DesignationGT))
	}
	if i.DesignationGTE != nil {
		predicates = append(predicates, customer.DesignationGTE(*i.DesignationGTE))
	}
	if i.DesignationLT != nil {
		predicates = append(predicates, customer.DesignationLT(*i.DesignationLT))
	}
	if i.DesignationLTE != nil {
		predicates = append(predicates, customer.DesignationLTE(*i.DesignationLTE))
	}
	if i.DesignationContains != nil {
		predicates = append(predicates, customer.DesignationContains(*i.DesignationContains))
	}
	if i.DesignationHasPrefix != nil {
		predicates = append(predicates, customer.DesignationHasPrefix(*i.DesignationHasPrefix))
	}
	if i.DesignationHasSuffix != nil {
		predicates = append(predicates, customer.DesignationHasSuffix(*i.DesignationHasSuffix))
	}
	if i.DesignationIsNil {
		predicates = append(predicates, customer.DesignationIsNil())
	}
	if i.DesignationNotNil {
		predicates = append(predicates, customer.DesignationNotNil())
	}
	if i.DesignationEqualFold != nil {
		predicates = append(predicates, customer.DesignationEqualFold(*i.DesignationEqualFold))
	}
	if i.DesignationContainsFold != nil {
		predicates = append(predicates, customer.DesignationContainsFold(*i.DesignationContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, customer.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, customer.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, customer.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, customer.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, customer.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, customer.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, customer.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, customer.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, customer.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, customer.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, customer.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleIsNil {
		predicates = append(predicates, customer.TitleIsNil())
	}
	if i.TitleNotNil {
		predicates = append(predicates, customer.TitleNotNil())
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, customer.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, customer.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, customer.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, customer.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, customer.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, customer.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, customer.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, customer.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, customer.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, customer.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, customer.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, customer.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, customer.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, customer.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, customer.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, customer.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, customer.NameContainsFold(*i.NameContainsFold))
	}
	if i.GivenName != nil {
		predicates = append(predicates, customer.GivenNameEQ(*i.GivenName))
	}
	if i.GivenNameNEQ != nil {
		predicates = append(predicates, customer.GivenNameNEQ(*i.GivenNameNEQ))
	}
	if len(i.GivenNameIn) > 0 {
		predicates = append(predicates, customer.GivenNameIn(i.GivenNameIn...))
	}
	if len(i.GivenNameNotIn) > 0 {
		predicates = append(predicates, customer.GivenNameNotIn(i.GivenNameNotIn...))
	}
	if i.GivenNameGT != nil {
		predicates = append(predicates, customer.GivenNameGT(*i.GivenNameGT))
	}
	if i.GivenNameGTE != nil {
		predicates = append(predicates, customer.GivenNameGTE(*i.GivenNameGTE))
	}
	if i.GivenNameLT != nil {
		predicates = append(predicates, customer.GivenNameLT(*i.GivenNameLT))
	}
	if i.GivenNameLTE != nil {
		predicates = append(predicates, customer.GivenNameLTE(*i.GivenNameLTE))
	}
	if i.GivenNameContains != nil {
		predicates = append(predicates, customer.GivenNameContains(*i.GivenNameContains))
	}
	if i.GivenNameHasPrefix != nil {
		predicates = append(predicates, customer.GivenNameHasPrefix(*i.GivenNameHasPrefix))
	}
	if i.GivenNameHasSuffix != nil {
		predicates = append(predicates, customer.GivenNameHasSuffix(*i.GivenNameHasSuffix))
	}
	if i.GivenNameIsNil {
		predicates = append(predicates, customer.GivenNameIsNil())
	}
	if i.GivenNameNotNil {
		predicates = append(predicates, customer.GivenNameNotNil())
	}
	if i.GivenNameEqualFold != nil {
		predicates = append(predicates, customer.GivenNameEqualFold(*i.GivenNameEqualFold))
	}
	if i.GivenNameContainsFold != nil {
		predicates = append(predicates, customer.GivenNameContainsFold(*i.GivenNameContainsFold))
	}
	if i.MiddleName != nil {
		predicates = append(predicates, customer.MiddleNameEQ(*i.MiddleName))
	}
	if i.MiddleNameNEQ != nil {
		predicates = append(predicates, customer.MiddleNameNEQ(*i.MiddleNameNEQ))
	}
	if len(i.MiddleNameIn) > 0 {
		predicates = append(predicates, customer.MiddleNameIn(i.MiddleNameIn...))
	}
	if len(i.MiddleNameNotIn) > 0 {
		predicates = append(predicates, customer.MiddleNameNotIn(i.MiddleNameNotIn...))
	}
	if i.MiddleNameGT != nil {
		predicates = append(predicates, customer.MiddleNameGT(*i.MiddleNameGT))
	}
	if i.MiddleNameGTE != nil {
		predicates = append(predicates, customer.MiddleNameGTE(*i.MiddleNameGTE))
	}
	if i.MiddleNameLT != nil {
		predicates = append(predicates, customer.MiddleNameLT(*i.MiddleNameLT))
	}
	if i.MiddleNameLTE != nil {
		predicates = append(predicates, customer.MiddleNameLTE(*i.MiddleNameLTE))
	}
	if i.MiddleNameContains != nil {
		predicates = append(predicates, customer.MiddleNameContains(*i.MiddleNameContains))
	}
	if i.MiddleNameHasPrefix != nil {
		predicates = append(predicates, customer.MiddleNameHasPrefix(*i.MiddleNameHasPrefix))
	}
	if i.MiddleNameHasSuffix != nil {
		predicates = append(predicates, customer.MiddleNameHasSuffix(*i.MiddleNameHasSuffix))
	}
	if i.MiddleNameIsNil {
		predicates = append(predicates, customer.MiddleNameIsNil())
	}
	if i.MiddleNameNotNil {
		predicates = append(predicates, customer.MiddleNameNotNil())
	}
	if i.MiddleNameEqualFold != nil {
		predicates = append(predicates, customer.MiddleNameEqualFold(*i.MiddleNameEqualFold))
	}
	if i.MiddleNameContainsFold != nil {
		predicates = append(predicates, customer.MiddleNameContainsFold(*i.MiddleNameContainsFold))
	}
	if i.FamilyName != nil {
		predicates = append(predicates, customer.FamilyNameEQ(*i.FamilyName))
	}
	if i.FamilyNameNEQ != nil {
		predicates = append(predicates, customer.FamilyNameNEQ(*i.FamilyNameNEQ))
	}
	if len(i.FamilyNameIn) > 0 {
		predicates = append(predicates, customer.FamilyNameIn(i.FamilyNameIn...))
	}
	if len(i.FamilyNameNotIn) > 0 {
		predicates = append(predicates, customer.FamilyNameNotIn(i.FamilyNameNotIn...))
	}
	if i.FamilyNameGT != nil {
		predicates = append(predicates, customer.FamilyNameGT(*i.FamilyNameGT))
	}
	if i.FamilyNameGTE != nil {
		predicates = append(predicates, customer.FamilyNameGTE(*i.FamilyNameGTE))
	}
	if i.FamilyNameLT != nil {
		predicates = append(predicates, customer.FamilyNameLT(*i.FamilyNameLT))
	}
	if i.FamilyNameLTE != nil {
		predicates = append(predicates, customer.FamilyNameLTE(*i.FamilyNameLTE))
	}
	if i.FamilyNameContains != nil {
		predicates = append(predicates, customer.FamilyNameContains(*i.FamilyNameContains))
	}
	if i.FamilyNameHasPrefix != nil {
		predicates = append(predicates, customer.FamilyNameHasPrefix(*i.FamilyNameHasPrefix))
	}
	if i.FamilyNameHasSuffix != nil {
		predicates = append(predicates, customer.FamilyNameHasSuffix(*i.FamilyNameHasSuffix))
	}
	if i.FamilyNameIsNil {
		predicates = append(predicates, customer.FamilyNameIsNil())
	}
	if i.FamilyNameNotNil {
		predicates = append(predicates, customer.FamilyNameNotNil())
	}
	if i.FamilyNameEqualFold != nil {
		predicates = append(predicates, customer.FamilyNameEqualFold(*i.FamilyNameEqualFold))
	}
	if i.FamilyNameContainsFold != nil {
		predicates = append(predicates, customer.FamilyNameContainsFold(*i.FamilyNameContainsFold))
	}
	if i.PhotoURL != nil {
		predicates = append(predicates, customer.PhotoURLEQ(*i.PhotoURL))
	}
	if i.PhotoURLNEQ != nil {
		predicates = append(predicates, customer.PhotoURLNEQ(*i.PhotoURLNEQ))
	}
	if len(i.PhotoURLIn) > 0 {
		predicates = append(predicates, customer.PhotoURLIn(i.PhotoURLIn...))
	}
	if len(i.PhotoURLNotIn) > 0 {
		predicates = append(predicates, customer.PhotoURLNotIn(i.PhotoURLNotIn...))
	}
	if i.PhotoURLGT != nil {
		predicates = append(predicates, customer.PhotoURLGT(*i.PhotoURLGT))
	}
	if i.PhotoURLGTE != nil {
		predicates = append(predicates, customer.PhotoURLGTE(*i.PhotoURLGTE))
	}
	if i.PhotoURLLT != nil {
		predicates = append(predicates, customer.PhotoURLLT(*i.PhotoURLLT))
	}
	if i.PhotoURLLTE != nil {
		predicates = append(predicates, customer.PhotoURLLTE(*i.PhotoURLLTE))
	}
	if i.PhotoURLContains != nil {
		predicates = append(predicates, customer.PhotoURLContains(*i.PhotoURLContains))
	}
	if i.PhotoURLHasPrefix != nil {
		predicates = append(predicates, customer.PhotoURLHasPrefix(*i.PhotoURLHasPrefix))
	}
	if i.PhotoURLHasSuffix != nil {
		predicates = append(predicates, customer.PhotoURLHasSuffix(*i.PhotoURLHasSuffix))
	}
	if i.PhotoURLIsNil {
		predicates = append(predicates, customer.PhotoURLIsNil())
	}
	if i.PhotoURLNotNil {
		predicates = append(predicates, customer.PhotoURLNotNil())
	}
	if i.PhotoURLEqualFold != nil {
		predicates = append(predicates, customer.PhotoURLEqualFold(*i.PhotoURLEqualFold))
	}
	if i.PhotoURLContainsFold != nil {
		predicates = append(predicates, customer.PhotoURLContainsFold(*i.PhotoURLContainsFold))
	}
	if i.PhotoURL24 != nil {
		predicates = append(predicates, customer.PhotoURL24EQ(*i.PhotoURL24))
	}
	if i.PhotoURL24NEQ != nil {
		predicates = append(predicates, customer.PhotoURL24NEQ(*i.PhotoURL24NEQ))
	}
	if len(i.PhotoURL24In) > 0 {
		predicates = append(predicates, customer.PhotoURL24In(i.PhotoURL24In...))
	}
	if len(i.PhotoURL24NotIn) > 0 {
		predicates = append(predicates, customer.PhotoURL24NotIn(i.PhotoURL24NotIn...))
	}
	if i.PhotoURL24GT != nil {
		predicates = append(predicates, customer.PhotoURL24GT(*i.PhotoURL24GT))
	}
	if i.PhotoURL24GTE != nil {
		predicates = append(predicates, customer.PhotoURL24GTE(*i.PhotoURL24GTE))
	}
	if i.PhotoURL24LT != nil {
		predicates = append(predicates, customer.PhotoURL24LT(*i.PhotoURL24LT))
	}
	if i.PhotoURL24LTE != nil {
		predicates = append(predicates, customer.PhotoURL24LTE(*i.PhotoURL24LTE))
	}
	if i.PhotoURL24Contains != nil {
		predicates = append(predicates, customer.PhotoURL24Contains(*i.PhotoURL24Contains))
	}
	if i.PhotoURL24HasPrefix != nil {
		predicates = append(predicates, customer.PhotoURL24HasPrefix(*i.PhotoURL24HasPrefix))
	}
	if i.PhotoURL24HasSuffix != nil {
		predicates = append(predicates, customer.PhotoURL24HasSuffix(*i.PhotoURL24HasSuffix))
	}
	if i.PhotoURL24IsNil {
		predicates = append(predicates, customer.PhotoURL24IsNil())
	}
	if i.PhotoURL24NotNil {
		predicates = append(predicates, customer.PhotoURL24NotNil())
	}
	if i.PhotoURL24EqualFold != nil {
		predicates = append(predicates, customer.PhotoURL24EqualFold(*i.PhotoURL24EqualFold))
	}
	if i.PhotoURL24ContainsFold != nil {
		predicates = append(predicates, customer.PhotoURL24ContainsFold(*i.PhotoURL24ContainsFold))
	}
	if i.PhotoURL32 != nil {
		predicates = append(predicates, customer.PhotoURL32EQ(*i.PhotoURL32))
	}
	if i.PhotoURL32NEQ != nil {
		predicates = append(predicates, customer.PhotoURL32NEQ(*i.PhotoURL32NEQ))
	}
	if len(i.PhotoURL32In) > 0 {
		predicates = append(predicates, customer.PhotoURL32In(i.PhotoURL32In...))
	}
	if len(i.PhotoURL32NotIn) > 0 {
		predicates = append(predicates, customer.PhotoURL32NotIn(i.PhotoURL32NotIn...))
	}
	if i.PhotoURL32GT != nil {
		predicates = append(predicates, customer.PhotoURL32GT(*i.PhotoURL32GT))
	}
	if i.PhotoURL32GTE != nil {
		predicates = append(predicates, customer.PhotoURL32GTE(*i.PhotoURL32GTE))
	}
	if i.PhotoURL32LT != nil {
		predicates = append(predicates, customer.PhotoURL32LT(*i.PhotoURL32LT))
	}
	if i.PhotoURL32LTE != nil {
		predicates = append(predicates, customer.PhotoURL32LTE(*i.PhotoURL32LTE))
	}
	if i.PhotoURL32Contains != nil {
		predicates = append(predicates, customer.PhotoURL32Contains(*i.PhotoURL32Contains))
	}
	if i.PhotoURL32HasPrefix != nil {
		predicates = append(predicates, customer.PhotoURL32HasPrefix(*i.PhotoURL32HasPrefix))
	}
	if i.PhotoURL32HasSuffix != nil {
		predicates = append(predicates, customer.PhotoURL32HasSuffix(*i.PhotoURL32HasSuffix))
	}
	if i.PhotoURL32IsNil {
		predicates = append(predicates, customer.PhotoURL32IsNil())
	}
	if i.PhotoURL32NotNil {
		predicates = append(predicates, customer.PhotoURL32NotNil())
	}
	if i.PhotoURL32EqualFold != nil {
		predicates = append(predicates, customer.PhotoURL32EqualFold(*i.PhotoURL32EqualFold))
	}
	if i.PhotoURL32ContainsFold != nil {
		predicates = append(predicates, customer.PhotoURL32ContainsFold(*i.PhotoURL32ContainsFold))
	}
	if i.PhotoURL48 != nil {
		predicates = append(predicates, customer.PhotoURL48EQ(*i.PhotoURL48))
	}
	if i.PhotoURL48NEQ != nil {
		predicates = append(predicates, customer.PhotoURL48NEQ(*i.PhotoURL48NEQ))
	}
	if len(i.PhotoURL48In) > 0 {
		predicates = append(predicates, customer.PhotoURL48In(i.PhotoURL48In...))
	}
	if len(i.PhotoURL48NotIn) > 0 {
		predicates = append(predicates, customer.PhotoURL48NotIn(i.PhotoURL48NotIn...))
	}
	if i.PhotoURL48GT != nil {
		predicates = append(predicates, customer.PhotoURL48GT(*i.PhotoURL48GT))
	}
	if i.PhotoURL48GTE != nil {
		predicates = append(predicates, customer.PhotoURL48GTE(*i.PhotoURL48GTE))
	}
	if i.PhotoURL48LT != nil {
		predicates = append(predicates, customer.PhotoURL48LT(*i.PhotoURL48LT))
	}
	if i.PhotoURL48LTE != nil {
		predicates = append(predicates, customer.PhotoURL48LTE(*i.PhotoURL48LTE))
	}
	if i.PhotoURL48Contains != nil {
		predicates = append(predicates, customer.PhotoURL48Contains(*i.PhotoURL48Contains))
	}
	if i.PhotoURL48HasPrefix != nil {
		predicates = append(predicates, customer.PhotoURL48HasPrefix(*i.PhotoURL48HasPrefix))
	}
	if i.PhotoURL48HasSuffix != nil {
		predicates = append(predicates, customer.PhotoURL48HasSuffix(*i.PhotoURL48HasSuffix))
	}
	if i.PhotoURL48IsNil {
		predicates = append(predicates, customer.PhotoURL48IsNil())
	}
	if i.PhotoURL48NotNil {
		predicates = append(predicates, customer.PhotoURL48NotNil())
	}
	if i.PhotoURL48EqualFold != nil {
		predicates = append(predicates, customer.PhotoURL48EqualFold(*i.PhotoURL48EqualFold))
	}
	if i.PhotoURL48ContainsFold != nil {
		predicates = append(predicates, customer.PhotoURL48ContainsFold(*i.PhotoURL48ContainsFold))
	}
	if i.PhotoURL72 != nil {
		predicates = append(predicates, customer.PhotoURL72EQ(*i.PhotoURL72))
	}
	if i.PhotoURL72NEQ != nil {
		predicates = append(predicates, customer.PhotoURL72NEQ(*i.PhotoURL72NEQ))
	}
	if len(i.PhotoURL72In) > 0 {
		predicates = append(predicates, customer.PhotoURL72In(i.PhotoURL72In...))
	}
	if len(i.PhotoURL72NotIn) > 0 {
		predicates = append(predicates, customer.PhotoURL72NotIn(i.PhotoURL72NotIn...))
	}
	if i.PhotoURL72GT != nil {
		predicates = append(predicates, customer.PhotoURL72GT(*i.PhotoURL72GT))
	}
	if i.PhotoURL72GTE != nil {
		predicates = append(predicates, customer.PhotoURL72GTE(*i.PhotoURL72GTE))
	}
	if i.PhotoURL72LT != nil {
		predicates = append(predicates, customer.PhotoURL72LT(*i.PhotoURL72LT))
	}
	if i.PhotoURL72LTE != nil {
		predicates = append(predicates, customer.PhotoURL72LTE(*i.PhotoURL72LTE))
	}
	if i.PhotoURL72Contains != nil {
		predicates = append(predicates, customer.PhotoURL72Contains(*i.PhotoURL72Contains))
	}
	if i.PhotoURL72HasPrefix != nil {
		predicates = append(predicates, customer.PhotoURL72HasPrefix(*i.PhotoURL72HasPrefix))
	}
	if i.PhotoURL72HasSuffix != nil {
		predicates = append(predicates, customer.PhotoURL72HasSuffix(*i.PhotoURL72HasSuffix))
	}
	if i.PhotoURL72IsNil {
		predicates = append(predicates, customer.PhotoURL72IsNil())
	}
	if i.PhotoURL72NotNil {
		predicates = append(predicates, customer.PhotoURL72NotNil())
	}
	if i.PhotoURL72EqualFold != nil {
		predicates = append(predicates, customer.PhotoURL72EqualFold(*i.PhotoURL72EqualFold))
	}
	if i.PhotoURL72ContainsFold != nil {
		predicates = append(predicates, customer.PhotoURL72ContainsFold(*i.PhotoURL72ContainsFold))
	}
	if i.PhotoURL192 != nil {
		predicates = append(predicates, customer.PhotoURL192EQ(*i.PhotoURL192))
	}
	if i.PhotoURL192NEQ != nil {
		predicates = append(predicates, customer.PhotoURL192NEQ(*i.PhotoURL192NEQ))
	}
	if len(i.PhotoURL192In) > 0 {
		predicates = append(predicates, customer.PhotoURL192In(i.PhotoURL192In...))
	}
	if len(i.PhotoURL192NotIn) > 0 {
		predicates = append(predicates, customer.PhotoURL192NotIn(i.PhotoURL192NotIn...))
	}
	if i.PhotoURL192GT != nil {
		predicates = append(predicates, customer.PhotoURL192GT(*i.PhotoURL192GT))
	}
	if i.PhotoURL192GTE != nil {
		predicates = append(predicates, customer.PhotoURL192GTE(*i.PhotoURL192GTE))
	}
	if i.PhotoURL192LT != nil {
		predicates = append(predicates, customer.PhotoURL192LT(*i.PhotoURL192LT))
	}
	if i.PhotoURL192LTE != nil {
		predicates = append(predicates, customer.PhotoURL192LTE(*i.PhotoURL192LTE))
	}
	if i.PhotoURL192Contains != nil {
		predicates = append(predicates, customer.PhotoURL192Contains(*i.PhotoURL192Contains))
	}
	if i.PhotoURL192HasPrefix != nil {
		predicates = append(predicates, customer.PhotoURL192HasPrefix(*i.PhotoURL192HasPrefix))
	}
	if i.PhotoURL192HasSuffix != nil {
		predicates = append(predicates, customer.PhotoURL192HasSuffix(*i.PhotoURL192HasSuffix))
	}
	if i.PhotoURL192IsNil {
		predicates = append(predicates, customer.PhotoURL192IsNil())
	}
	if i.PhotoURL192NotNil {
		predicates = append(predicates, customer.PhotoURL192NotNil())
	}
	if i.PhotoURL192EqualFold != nil {
		predicates = append(predicates, customer.PhotoURL192EqualFold(*i.PhotoURL192EqualFold))
	}
	if i.PhotoURL192ContainsFold != nil {
		predicates = append(predicates, customer.PhotoURL192ContainsFold(*i.PhotoURL192ContainsFold))
	}
	if i.PhotoURL512 != nil {
		predicates = append(predicates, customer.PhotoURL512EQ(*i.PhotoURL512))
	}
	if i.PhotoURL512NEQ != nil {
		predicates = append(predicates, customer.PhotoURL512NEQ(*i.PhotoURL512NEQ))
	}
	if len(i.PhotoURL512In) > 0 {
		predicates = append(predicates, customer.PhotoURL512In(i.PhotoURL512In...))
	}
	if len(i.PhotoURL512NotIn) > 0 {
		predicates = append(predicates, customer.PhotoURL512NotIn(i.PhotoURL512NotIn...))
	}
	if i.PhotoURL512GT != nil {
		predicates = append(predicates, customer.PhotoURL512GT(*i.PhotoURL512GT))
	}
	if i.PhotoURL512GTE != nil {
		predicates = append(predicates, customer.PhotoURL512GTE(*i.PhotoURL512GTE))
	}
	if i.PhotoURL512LT != nil {
		predicates = append(predicates, customer.PhotoURL512LT(*i.PhotoURL512LT))
	}
	if i.PhotoURL512LTE != nil {
		predicates = append(predicates, customer.PhotoURL512LTE(*i.PhotoURL512LTE))
	}
	if i.PhotoURL512Contains != nil {
		predicates = append(predicates, customer.PhotoURL512Contains(*i.PhotoURL512Contains))
	}
	if i.PhotoURL512HasPrefix != nil {
		predicates = append(predicates, customer.PhotoURL512HasPrefix(*i.PhotoURL512HasPrefix))
	}
	if i.PhotoURL512HasSuffix != nil {
		predicates = append(predicates, customer.PhotoURL512HasSuffix(*i.PhotoURL512HasSuffix))
	}
	if i.PhotoURL512IsNil {
		predicates = append(predicates, customer.PhotoURL512IsNil())
	}
	if i.PhotoURL512NotNil {
		predicates = append(predicates, customer.PhotoURL512NotNil())
	}
	if i.PhotoURL512EqualFold != nil {
		predicates = append(predicates, customer.PhotoURL512EqualFold(*i.PhotoURL512EqualFold))
	}
	if i.PhotoURL512ContainsFold != nil {
		predicates = append(predicates, customer.PhotoURL512ContainsFold(*i.PhotoURL512ContainsFold))
	}
	if i.Timezone != nil {
		predicates = append(predicates, customer.TimezoneEQ(*i.Timezone))
	}
	if i.TimezoneNEQ != nil {
		predicates = append(predicates, customer.TimezoneNEQ(*i.TimezoneNEQ))
	}
	if len(i.TimezoneIn) > 0 {
		predicates = append(predicates, customer.TimezoneIn(i.TimezoneIn...))
	}
	if len(i.TimezoneNotIn) > 0 {
		predicates = append(predicates, customer.TimezoneNotIn(i.TimezoneNotIn...))
	}
	if i.TimezoneGT != nil {
		predicates = append(predicates, customer.TimezoneGT(*i.TimezoneGT))
	}
	if i.TimezoneGTE != nil {
		predicates = append(predicates, customer.TimezoneGTE(*i.TimezoneGTE))
	}
	if i.TimezoneLT != nil {
		predicates = append(predicates, customer.TimezoneLT(*i.TimezoneLT))
	}
	if i.TimezoneLTE != nil {
		predicates = append(predicates, customer.TimezoneLTE(*i.TimezoneLTE))
	}
	if i.TimezoneContains != nil {
		predicates = append(predicates, customer.TimezoneContains(*i.TimezoneContains))
	}
	if i.TimezoneHasPrefix != nil {
		predicates = append(predicates, customer.TimezoneHasPrefix(*i.TimezoneHasPrefix))
	}
	if i.TimezoneHasSuffix != nil {
		predicates = append(predicates, customer.TimezoneHasSuffix(*i.TimezoneHasSuffix))
	}
	if i.TimezoneIsNil {
		predicates = append(predicates, customer.TimezoneIsNil())
	}
	if i.TimezoneNotNil {
		predicates = append(predicates, customer.TimezoneNotNil())
	}
	if i.TimezoneEqualFold != nil {
		predicates = append(predicates, customer.TimezoneEqualFold(*i.TimezoneEqualFold))
	}
	if i.TimezoneContainsFold != nil {
		predicates = append(predicates, customer.TimezoneContainsFold(*i.TimezoneContainsFold))
	}
	if i.Locale != nil {
		predicates = append(predicates, customer.LocaleEQ(*i.Locale))
	}
	if i.LocaleNEQ != nil {
		predicates = append(predicates, customer.LocaleNEQ(*i.LocaleNEQ))
	}
	if len(i.LocaleIn) > 0 {
		predicates = append(predicates, customer.LocaleIn(i.LocaleIn...))
	}
	if len(i.LocaleNotIn) > 0 {
		predicates = append(predicates, customer.LocaleNotIn(i.LocaleNotIn...))
	}
	if i.LocaleGT != nil {
		predicates = append(predicates, customer.LocaleGT(*i.LocaleGT))
	}
	if i.LocaleGTE != nil {
		predicates = append(predicates, customer.LocaleGTE(*i.LocaleGTE))
	}
	if i.LocaleLT != nil {
		predicates = append(predicates, customer.LocaleLT(*i.LocaleLT))
	}
	if i.LocaleLTE != nil {
		predicates = append(predicates, customer.LocaleLTE(*i.LocaleLTE))
	}
	if i.LocaleContains != nil {
		predicates = append(predicates, customer.LocaleContains(*i.LocaleContains))
	}
	if i.LocaleHasPrefix != nil {
		predicates = append(predicates, customer.LocaleHasPrefix(*i.LocaleHasPrefix))
	}
	if i.LocaleHasSuffix != nil {
		predicates = append(predicates, customer.LocaleHasSuffix(*i.LocaleHasSuffix))
	}
	if i.LocaleIsNil {
		predicates = append(predicates, customer.LocaleIsNil())
	}
	if i.LocaleNotNil {
		predicates = append(predicates, customer.LocaleNotNil())
	}
	if i.LocaleEqualFold != nil {
		predicates = append(predicates, customer.LocaleEqualFold(*i.LocaleEqualFold))
	}
	if i.LocaleContainsFold != nil {
		predicates = append(predicates, customer.LocaleContainsFold(*i.LocaleContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, customer.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, customer.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, customer.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, customer.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, customer.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, customer.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, customer.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, customer.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.ModifiedAt != nil {
		predicates = append(predicates, customer.ModifiedAtEQ(*i.ModifiedAt))
	}
	if i.ModifiedAtNEQ != nil {
		predicates = append(predicates, customer.ModifiedAtNEQ(*i.ModifiedAtNEQ))
	}
	if len(i.ModifiedAtIn) > 0 {
		predicates = append(predicates, customer.ModifiedAtIn(i.ModifiedAtIn...))
	}
	if len(i.ModifiedAtNotIn) > 0 {
		predicates = append(predicates, customer.ModifiedAtNotIn(i.ModifiedAtNotIn...))
	}
	if i.ModifiedAtGT != nil {
		predicates = append(predicates, customer.ModifiedAtGT(*i.ModifiedAtGT))
	}
	if i.ModifiedAtGTE != nil {
		predicates = append(predicates, customer.ModifiedAtGTE(*i.ModifiedAtGTE))
	}
	if i.ModifiedAtLT != nil {
		predicates = append(predicates, customer.ModifiedAtLT(*i.ModifiedAtLT))
	}
	if i.ModifiedAtLTE != nil {
		predicates = append(predicates, customer.ModifiedAtLTE(*i.ModifiedAtLTE))
	}
	if i.ModifiedAtIsNil {
		predicates = append(predicates, customer.ModifiedAtIsNil())
	}
	if i.ModifiedAtNotNil {
		predicates = append(predicates, customer.ModifiedAtNotNil())
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, customer.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, customer.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, customer.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, customer.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, customer.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, customer.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, customer.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, customer.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, customer.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, customer.DeletedAtNotNil())
	}

	if i.HasIdentities != nil {
		p := customer.HasIdentities()
		if !*i.HasIdentities {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIdentitiesWith) > 0 {
		with := make([]predicate.Identity, 0, len(i.HasIdentitiesWith))
		for _, w := range i.HasIdentitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIdentitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasIdentitiesWith(with...))
	}
	if i.HasCustomerSettings != nil {
		p := customer.HasCustomerSettings()
		if !*i.HasCustomerSettings {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomerSettingsWith) > 0 {
		with := make([]predicate.CustomerSetting, 0, len(i.HasCustomerSettingsWith))
		for _, w := range i.HasCustomerSettingsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomerSettingsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasCustomerSettingsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCustomerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return customer.And(predicates...), nil
	}
}

// CustomerOutboxWhereInput represents a where input for filtering CustomerOutbox queries.
type CustomerOutboxWhereInput struct {
	Predicates []predicate.CustomerOutbox  `json:"-"`
	Not        *CustomerOutboxWhereInput   `json:"not,omitempty"`
	Or         []*CustomerOutboxWhereInput `json:"or,omitempty"`
	And        []*CustomerOutboxWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "timestamp" field predicates.
	Timestamp      *time.Time  `json:"timestamp,omitempty"`
	TimestampNEQ   *time.Time  `json:"timestampNEQ,omitempty"`
	TimestampIn    []time.Time `json:"timestampIn,omitempty"`
	TimestampNotIn []time.Time `json:"timestampNotIn,omitempty"`
	TimestampGT    *time.Time  `json:"timestampGT,omitempty"`
	TimestampGTE   *time.Time  `json:"timestampGTE,omitempty"`
	TimestampLT    *time.Time  `json:"timestampLT,omitempty"`
	TimestampLTE   *time.Time  `json:"timestampLTE,omitempty"`

	// "topic" field predicates.
	Topic             *string  `json:"topic,omitempty"`
	TopicNEQ          *string  `json:"topicNEQ,omitempty"`
	TopicIn           []string `json:"topicIn,omitempty"`
	TopicNotIn        []string `json:"topicNotIn,omitempty"`
	TopicGT           *string  `json:"topicGT,omitempty"`
	TopicGTE          *string  `json:"topicGTE,omitempty"`
	TopicLT           *string  `json:"topicLT,omitempty"`
	TopicLTE          *string  `json:"topicLTE,omitempty"`
	TopicContains     *string  `json:"topicContains,omitempty"`
	TopicHasPrefix    *string  `json:"topicHasPrefix,omitempty"`
	TopicHasSuffix    *string  `json:"topicHasSuffix,omitempty"`
	TopicEqualFold    *string  `json:"topicEqualFold,omitempty"`
	TopicContainsFold *string  `json:"topicContainsFold,omitempty"`

	// "retry_count" field predicates.
	RetryCount      *int  `json:"retryCount,omitempty"`
	RetryCountNEQ   *int  `json:"retryCountNEQ,omitempty"`
	RetryCountIn    []int `json:"retryCountIn,omitempty"`
	RetryCountNotIn []int `json:"retryCountNotIn,omitempty"`
	RetryCountGT    *int  `json:"retryCountGT,omitempty"`
	RetryCountGTE   *int  `json:"retryCountGTE,omitempty"`
	RetryCountLT    *int  `json:"retryCountLT,omitempty"`
	RetryCountLTE   *int  `json:"retryCountLTE,omitempty"`

	// "status" field predicates.
	Status      *customeroutbox.Status  `json:"status,omitempty"`
	StatusNEQ   *customeroutbox.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []customeroutbox.Status `json:"statusIn,omitempty"`
	StatusNotIn []customeroutbox.Status `json:"statusNotIn,omitempty"`

	// "last_retry" field predicates.
	LastRetry       *time.Time  `json:"lastRetry,omitempty"`
	LastRetryNEQ    *time.Time  `json:"lastRetryNEQ,omitempty"`
	LastRetryIn     []time.Time `json:"lastRetryIn,omitempty"`
	LastRetryNotIn  []time.Time `json:"lastRetryNotIn,omitempty"`
	LastRetryGT     *time.Time  `json:"lastRetryGT,omitempty"`
	LastRetryGTE    *time.Time  `json:"lastRetryGTE,omitempty"`
	LastRetryLT     *time.Time  `json:"lastRetryLT,omitempty"`
	LastRetryLTE    *time.Time  `json:"lastRetryLTE,omitempty"`
	LastRetryIsNil  bool        `json:"lastRetryIsNil,omitempty"`
	LastRetryNotNil bool        `json:"lastRetryNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CustomerOutboxWhereInput) AddPredicates(predicates ...predicate.CustomerOutbox) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CustomerOutboxWhereInput filter on the CustomerOutboxQuery builder.
func (i *CustomerOutboxWhereInput) Filter(q *CustomerOutboxQuery) (*CustomerOutboxQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCustomerOutboxWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCustomerOutboxWhereInput is returned in case the CustomerOutboxWhereInput is empty.
var ErrEmptyCustomerOutboxWhereInput = errors.New("entities: empty predicate CustomerOutboxWhereInput")

// P returns a predicate for filtering customeroutboxes.
// An error is returned if the input is empty or invalid.
func (i *CustomerOutboxWhereInput) P() (predicate.CustomerOutbox, error) {
	var predicates []predicate.CustomerOutbox
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, customeroutbox.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CustomerOutbox, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, customeroutbox.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CustomerOutbox, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, customeroutbox.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, customeroutbox.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, customeroutbox.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, customeroutbox.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, customeroutbox.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, customeroutbox.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, customeroutbox.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, customeroutbox.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, customeroutbox.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, customeroutbox.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, customeroutbox.IDContainsFold(*i.IDContainsFold))
	}
	if i.Timestamp != nil {
		predicates = append(predicates, customeroutbox.TimestampEQ(*i.Timestamp))
	}
	if i.TimestampNEQ != nil {
		predicates = append(predicates, customeroutbox.TimestampNEQ(*i.TimestampNEQ))
	}
	if len(i.TimestampIn) > 0 {
		predicates = append(predicates, customeroutbox.TimestampIn(i.TimestampIn...))
	}
	if len(i.TimestampNotIn) > 0 {
		predicates = append(predicates, customeroutbox.TimestampNotIn(i.TimestampNotIn...))
	}
	if i.TimestampGT != nil {
		predicates = append(predicates, customeroutbox.TimestampGT(*i.TimestampGT))
	}
	if i.TimestampGTE != nil {
		predicates = append(predicates, customeroutbox.TimestampGTE(*i.TimestampGTE))
	}
	if i.TimestampLT != nil {
		predicates = append(predicates, customeroutbox.TimestampLT(*i.TimestampLT))
	}
	if i.TimestampLTE != nil {
		predicates = append(predicates, customeroutbox.TimestampLTE(*i.TimestampLTE))
	}
	if i.Topic != nil {
		predicates = append(predicates, customeroutbox.TopicEQ(*i.Topic))
	}
	if i.TopicNEQ != nil {
		predicates = append(predicates, customeroutbox.TopicNEQ(*i.TopicNEQ))
	}
	if len(i.TopicIn) > 0 {
		predicates = append(predicates, customeroutbox.TopicIn(i.TopicIn...))
	}
	if len(i.TopicNotIn) > 0 {
		predicates = append(predicates, customeroutbox.TopicNotIn(i.TopicNotIn...))
	}
	if i.TopicGT != nil {
		predicates = append(predicates, customeroutbox.TopicGT(*i.TopicGT))
	}
	if i.TopicGTE != nil {
		predicates = append(predicates, customeroutbox.TopicGTE(*i.TopicGTE))
	}
	if i.TopicLT != nil {
		predicates = append(predicates, customeroutbox.TopicLT(*i.TopicLT))
	}
	if i.TopicLTE != nil {
		predicates = append(predicates, customeroutbox.TopicLTE(*i.TopicLTE))
	}
	if i.TopicContains != nil {
		predicates = append(predicates, customeroutbox.TopicContains(*i.TopicContains))
	}
	if i.TopicHasPrefix != nil {
		predicates = append(predicates, customeroutbox.TopicHasPrefix(*i.TopicHasPrefix))
	}
	if i.TopicHasSuffix != nil {
		predicates = append(predicates, customeroutbox.TopicHasSuffix(*i.TopicHasSuffix))
	}
	if i.TopicEqualFold != nil {
		predicates = append(predicates, customeroutbox.TopicEqualFold(*i.TopicEqualFold))
	}
	if i.TopicContainsFold != nil {
		predicates = append(predicates, customeroutbox.TopicContainsFold(*i.TopicContainsFold))
	}
	if i.RetryCount != nil {
		predicates = append(predicates, customeroutbox.RetryCountEQ(*i.RetryCount))
	}
	if i.RetryCountNEQ != nil {
		predicates = append(predicates, customeroutbox.RetryCountNEQ(*i.RetryCountNEQ))
	}
	if len(i.RetryCountIn) > 0 {
		predicates = append(predicates, customeroutbox.RetryCountIn(i.RetryCountIn...))
	}
	if len(i.RetryCountNotIn) > 0 {
		predicates = append(predicates, customeroutbox.RetryCountNotIn(i.RetryCountNotIn...))
	}
	if i.RetryCountGT != nil {
		predicates = append(predicates, customeroutbox.RetryCountGT(*i.RetryCountGT))
	}
	if i.RetryCountGTE != nil {
		predicates = append(predicates, customeroutbox.RetryCountGTE(*i.RetryCountGTE))
	}
	if i.RetryCountLT != nil {
		predicates = append(predicates, customeroutbox.RetryCountLT(*i.RetryCountLT))
	}
	if i.RetryCountLTE != nil {
		predicates = append(predicates, customeroutbox.RetryCountLTE(*i.RetryCountLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, customeroutbox.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, customeroutbox.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, customeroutbox.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, customeroutbox.StatusNotIn(i.StatusNotIn...))
	}
	if i.LastRetry != nil {
		predicates = append(predicates, customeroutbox.LastRetryEQ(*i.LastRetry))
	}
	if i.LastRetryNEQ != nil {
		predicates = append(predicates, customeroutbox.LastRetryNEQ(*i.LastRetryNEQ))
	}
	if len(i.LastRetryIn) > 0 {
		predicates = append(predicates, customeroutbox.LastRetryIn(i.LastRetryIn...))
	}
	if len(i.LastRetryNotIn) > 0 {
		predicates = append(predicates, customeroutbox.LastRetryNotIn(i.LastRetryNotIn...))
	}
	if i.LastRetryGT != nil {
		predicates = append(predicates, customeroutbox.LastRetryGT(*i.LastRetryGT))
	}
	if i.LastRetryGTE != nil {
		predicates = append(predicates, customeroutbox.LastRetryGTE(*i.LastRetryGTE))
	}
	if i.LastRetryLT != nil {
		predicates = append(predicates, customeroutbox.LastRetryLT(*i.LastRetryLT))
	}
	if i.LastRetryLTE != nil {
		predicates = append(predicates, customeroutbox.LastRetryLTE(*i.LastRetryLTE))
	}
	if i.LastRetryIsNil {
		predicates = append(predicates, customeroutbox.LastRetryIsNil())
	}
	if i.LastRetryNotNil {
		predicates = append(predicates, customeroutbox.LastRetryNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCustomerOutboxWhereInput
	case 1:
		return predicates[0], nil
	default:
		return customeroutbox.And(predicates...), nil
	}
}

// CustomerSettingWhereInput represents a where input for filtering CustomerSetting queries.
type CustomerSettingWhereInput struct {
	Predicates []predicate.CustomerSetting  `json:"-"`
	Not        *CustomerSettingWhereInput   `json:"not,omitempty"`
	Or         []*CustomerSettingWhereInput `json:"or,omitempty"`
	And        []*CustomerSettingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "modified_at" field predicates.
	ModifiedAt       *time.Time  `json:"modifiedAt,omitempty"`
	ModifiedAtNEQ    *time.Time  `json:"modifiedAtNEQ,omitempty"`
	ModifiedAtIn     []time.Time `json:"modifiedAtIn,omitempty"`
	ModifiedAtNotIn  []time.Time `json:"modifiedAtNotIn,omitempty"`
	ModifiedAtGT     *time.Time  `json:"modifiedAtGT,omitempty"`
	ModifiedAtGTE    *time.Time  `json:"modifiedAtGTE,omitempty"`
	ModifiedAtLT     *time.Time  `json:"modifiedAtLT,omitempty"`
	ModifiedAtLTE    *time.Time  `json:"modifiedAtLTE,omitempty"`
	ModifiedAtIsNil  bool        `json:"modifiedAtIsNil,omitempty"`
	ModifiedAtNotNil bool        `json:"modifiedAtNotNil,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "customer" edge predicates.
	HasCustomer     *bool                 `json:"hasCustomer,omitempty"`
	HasCustomerWith []*CustomerWhereInput `json:"hasCustomerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CustomerSettingWhereInput) AddPredicates(predicates ...predicate.CustomerSetting) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CustomerSettingWhereInput filter on the CustomerSettingQuery builder.
func (i *CustomerSettingWhereInput) Filter(q *CustomerSettingQuery) (*CustomerSettingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCustomerSettingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCustomerSettingWhereInput is returned in case the CustomerSettingWhereInput is empty.
var ErrEmptyCustomerSettingWhereInput = errors.New("entities: empty predicate CustomerSettingWhereInput")

// P returns a predicate for filtering customersettings.
// An error is returned if the input is empty or invalid.
func (i *CustomerSettingWhereInput) P() (predicate.CustomerSetting, error) {
	var predicates []predicate.CustomerSetting
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, customersetting.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CustomerSetting, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, customersetting.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CustomerSetting, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, customersetting.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, customersetting.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, customersetting.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, customersetting.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, customersetting.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, customersetting.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, customersetting.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, customersetting.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, customersetting.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, customersetting.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, customersetting.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, customersetting.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, customersetting.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, customersetting.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, customersetting.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, customersetting.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, customersetting.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, customersetting.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, customersetting.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.ModifiedAt != nil {
		predicates = append(predicates, customersetting.ModifiedAtEQ(*i.ModifiedAt))
	}
	if i.ModifiedAtNEQ != nil {
		predicates = append(predicates, customersetting.ModifiedAtNEQ(*i.ModifiedAtNEQ))
	}
	if len(i.ModifiedAtIn) > 0 {
		predicates = append(predicates, customersetting.ModifiedAtIn(i.ModifiedAtIn...))
	}
	if len(i.ModifiedAtNotIn) > 0 {
		predicates = append(predicates, customersetting.ModifiedAtNotIn(i.ModifiedAtNotIn...))
	}
	if i.ModifiedAtGT != nil {
		predicates = append(predicates, customersetting.ModifiedAtGT(*i.ModifiedAtGT))
	}
	if i.ModifiedAtGTE != nil {
		predicates = append(predicates, customersetting.ModifiedAtGTE(*i.ModifiedAtGTE))
	}
	if i.ModifiedAtLT != nil {
		predicates = append(predicates, customersetting.ModifiedAtLT(*i.ModifiedAtLT))
	}
	if i.ModifiedAtLTE != nil {
		predicates = append(predicates, customersetting.ModifiedAtLTE(*i.ModifiedAtLTE))
	}
	if i.ModifiedAtIsNil {
		predicates = append(predicates, customersetting.ModifiedAtIsNil())
	}
	if i.ModifiedAtNotNil {
		predicates = append(predicates, customersetting.ModifiedAtNotNil())
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, customersetting.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, customersetting.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, customersetting.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, customersetting.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, customersetting.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, customersetting.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, customersetting.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, customersetting.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, customersetting.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, customersetting.DeletedAtNotNil())
	}

	if i.HasCustomer != nil {
		p := customersetting.HasCustomer()
		if !*i.HasCustomer {
			p = customersetting.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomerWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasCustomerWith))
		for _, w := range i.HasCustomerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customersetting.HasCustomerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCustomerSettingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return customersetting.And(predicates...), nil
	}
}

// IdentityWhereInput represents a where input for filtering Identity queries.
type IdentityWhereInput struct {
	Predicates []predicate.Identity  `json:"-"`
	Not        *IdentityWhereInput   `json:"not,omitempty"`
	Or         []*IdentityWhereInput `json:"or,omitempty"`
	And        []*IdentityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "email_verified" field predicates.
	EmailVerified       *bool `json:"emailVerified,omitempty"`
	EmailVerifiedNEQ    *bool `json:"emailVerifiedNEQ,omitempty"`
	EmailVerifiedIsNil  bool  `json:"emailVerifiedIsNil,omitempty"`
	EmailVerifiedNotNil bool  `json:"emailVerifiedNotNil,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "modified_at" field predicates.
	ModifiedAt       *time.Time  `json:"modifiedAt,omitempty"`
	ModifiedAtNEQ    *time.Time  `json:"modifiedAtNEQ,omitempty"`
	ModifiedAtIn     []time.Time `json:"modifiedAtIn,omitempty"`
	ModifiedAtNotIn  []time.Time `json:"modifiedAtNotIn,omitempty"`
	ModifiedAtGT     *time.Time  `json:"modifiedAtGT,omitempty"`
	ModifiedAtGTE    *time.Time  `json:"modifiedAtGTE,omitempty"`
	ModifiedAtLT     *time.Time  `json:"modifiedAtLT,omitempty"`
	ModifiedAtLTE    *time.Time  `json:"modifiedAtLTE,omitempty"`
	ModifiedAtIsNil  bool        `json:"modifiedAtIsNil,omitempty"`
	ModifiedAtNotNil bool        `json:"modifiedAtNotNil,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "customer" edge predicates.
	HasCustomer     *bool                 `json:"hasCustomer,omitempty"`
	HasCustomerWith []*CustomerWhereInput `json:"hasCustomerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *IdentityWhereInput) AddPredicates(predicates ...predicate.Identity) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the IdentityWhereInput filter on the IdentityQuery builder.
func (i *IdentityWhereInput) Filter(q *IdentityQuery) (*IdentityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyIdentityWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyIdentityWhereInput is returned in case the IdentityWhereInput is empty.
var ErrEmptyIdentityWhereInput = errors.New("entities: empty predicate IdentityWhereInput")

// P returns a predicate for filtering identities.
// An error is returned if the input is empty or invalid.
func (i *IdentityWhereInput) P() (predicate.Identity, error) {
	var predicates []predicate.Identity
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, identity.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Identity, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, identity.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Identity, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, identity.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, identity.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, identity.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, identity.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, identity.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, identity.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, identity.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, identity.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, identity.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, identity.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, identity.IDContainsFold(*i.IDContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, identity.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, identity.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, identity.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, identity.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, identity.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, identity.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, identity.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, identity.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, identity.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, identity.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, identity.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, identity.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, identity.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, identity.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, identity.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.EmailVerified != nil {
		predicates = append(predicates, identity.EmailVerifiedEQ(*i.EmailVerified))
	}
	if i.EmailVerifiedNEQ != nil {
		predicates = append(predicates, identity.EmailVerifiedNEQ(*i.EmailVerifiedNEQ))
	}
	if i.EmailVerifiedIsNil {
		predicates = append(predicates, identity.EmailVerifiedIsNil())
	}
	if i.EmailVerifiedNotNil {
		predicates = append(predicates, identity.EmailVerifiedNotNil())
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, identity.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, identity.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, identity.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, identity.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, identity.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, identity.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, identity.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, identity.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.ModifiedAt != nil {
		predicates = append(predicates, identity.ModifiedAtEQ(*i.ModifiedAt))
	}
	if i.ModifiedAtNEQ != nil {
		predicates = append(predicates, identity.ModifiedAtNEQ(*i.ModifiedAtNEQ))
	}
	if len(i.ModifiedAtIn) > 0 {
		predicates = append(predicates, identity.ModifiedAtIn(i.ModifiedAtIn...))
	}
	if len(i.ModifiedAtNotIn) > 0 {
		predicates = append(predicates, identity.ModifiedAtNotIn(i.ModifiedAtNotIn...))
	}
	if i.ModifiedAtGT != nil {
		predicates = append(predicates, identity.ModifiedAtGT(*i.ModifiedAtGT))
	}
	if i.ModifiedAtGTE != nil {
		predicates = append(predicates, identity.ModifiedAtGTE(*i.ModifiedAtGTE))
	}
	if i.ModifiedAtLT != nil {
		predicates = append(predicates, identity.ModifiedAtLT(*i.ModifiedAtLT))
	}
	if i.ModifiedAtLTE != nil {
		predicates = append(predicates, identity.ModifiedAtLTE(*i.ModifiedAtLTE))
	}
	if i.ModifiedAtIsNil {
		predicates = append(predicates, identity.ModifiedAtIsNil())
	}
	if i.ModifiedAtNotNil {
		predicates = append(predicates, identity.ModifiedAtNotNil())
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, identity.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, identity.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, identity.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, identity.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, identity.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, identity.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, identity.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, identity.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, identity.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, identity.DeletedAtNotNil())
	}

	if i.HasCustomer != nil {
		p := identity.HasCustomer()
		if !*i.HasCustomer {
			p = identity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomerWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasCustomerWith))
		for _, w := range i.HasCustomerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, identity.HasCustomerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyIdentityWhereInput
	case 1:
		return predicates[0], nil
	default:
		return identity.And(predicates...), nil
	}
}
