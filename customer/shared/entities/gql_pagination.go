// Code generated by ent, DO NOT EDIT.

package entities

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/sigmasee/sigmasee/customer/shared/entities/customer"
	"github.com/sigmasee/sigmasee/customer/shared/entities/customeroutbox"
	"github.com/sigmasee/sigmasee/customer/shared/entities/customersetting"
	"github.com/sigmasee/sigmasee/customer/shared/entities/identity"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[string]
	PageInfo       = entgql.PageInfo[string]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// CustomerEdge is the edge representation of Customer.
type CustomerEdge struct {
	Node   *Customer `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// CustomerConnection is the connection containing edges to Customer.
type CustomerConnection struct {
	Edges      []*CustomerEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *CustomerConnection) build(nodes []*Customer, pager *customerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Customer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Customer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Customer {
			return nodes[i]
		}
	}
	c.Edges = make([]*CustomerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CustomerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CustomerPaginateOption enables pagination customization.
type CustomerPaginateOption func(*customerPager) error

// WithCustomerOrder configures pagination ordering.
func WithCustomerOrder(order *CustomerOrder) CustomerPaginateOption {
	if order == nil {
		order = DefaultCustomerOrder
	}
	o := *order
	return func(pager *customerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCustomerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCustomerFilter configures pagination filter.
func WithCustomerFilter(filter func(*CustomerQuery) (*CustomerQuery, error)) CustomerPaginateOption {
	return func(pager *customerPager) error {
		if filter == nil {
			return errors.New("CustomerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customerPager struct {
	reverse bool
	order   *CustomerOrder
	filter  func(*CustomerQuery) (*CustomerQuery, error)
}

func newCustomerPager(opts []CustomerPaginateOption, reverse bool) (*customerPager, error) {
	pager := &customerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCustomerOrder
	}
	return pager, nil
}

func (p *customerPager) applyFilter(query *CustomerQuery) (*CustomerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customerPager) toCursor(c *Customer) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *customerPager) applyCursors(query *CustomerQuery, after, before *Cursor) (*CustomerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCustomerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *customerPager) applyOrder(query *CustomerQuery) *CustomerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCustomerOrder.Field {
		query = query.Order(DefaultCustomerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *customerPager) orderExpr(query *CustomerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCustomerOrder.Field {
			b.Comma().Ident(DefaultCustomerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Customer.
func (c *CustomerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomerPaginateOption,
) (*CustomerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CustomerConnection{Edges: []*CustomerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CustomerOrderFieldID orders Customer by id.
	CustomerOrderFieldID = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.ID, nil
		},
		column: customer.FieldID,
		toTerm: customer.ByID,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.ID,
			}
		},
	}
	// CustomerOrderFieldDesignation orders Customer by designation.
	CustomerOrderFieldDesignation = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.Designation, nil
		},
		column: customer.FieldDesignation,
		toTerm: customer.ByDesignation,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Designation,
			}
		},
	}
	// CustomerOrderFieldTitle orders Customer by title.
	CustomerOrderFieldTitle = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.Title, nil
		},
		column: customer.FieldTitle,
		toTerm: customer.ByTitle,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Title,
			}
		},
	}
	// CustomerOrderFieldName orders Customer by name.
	CustomerOrderFieldName = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.Name, nil
		},
		column: customer.FieldName,
		toTerm: customer.ByName,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
	// CustomerOrderFieldGivenName orders Customer by given_name.
	CustomerOrderFieldGivenName = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.GivenName, nil
		},
		column: customer.FieldGivenName,
		toTerm: customer.ByGivenName,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.GivenName,
			}
		},
	}
	// CustomerOrderFieldMiddleName orders Customer by middle_name.
	CustomerOrderFieldMiddleName = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.MiddleName, nil
		},
		column: customer.FieldMiddleName,
		toTerm: customer.ByMiddleName,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.MiddleName,
			}
		},
	}
	// CustomerOrderFieldFamilyName orders Customer by family_name.
	CustomerOrderFieldFamilyName = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.FamilyName, nil
		},
		column: customer.FieldFamilyName,
		toTerm: customer.ByFamilyName,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.FamilyName,
			}
		},
	}
	// CustomerOrderFieldPhotoURL orders Customer by photo_url.
	CustomerOrderFieldPhotoURL = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.PhotoURL, nil
		},
		column: customer.FieldPhotoURL,
		toTerm: customer.ByPhotoURL,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.PhotoURL,
			}
		},
	}
	// CustomerOrderFieldPhotoURL24 orders Customer by photo_url_24.
	CustomerOrderFieldPhotoURL24 = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.PhotoURL24, nil
		},
		column: customer.FieldPhotoURL24,
		toTerm: customer.ByPhotoURL24,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.PhotoURL24,
			}
		},
	}
	// CustomerOrderFieldPhotoURL32 orders Customer by photo_url_32.
	CustomerOrderFieldPhotoURL32 = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.PhotoURL32, nil
		},
		column: customer.FieldPhotoURL32,
		toTerm: customer.ByPhotoURL32,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.PhotoURL32,
			}
		},
	}
	// CustomerOrderFieldPhotoURL48 orders Customer by photo_url_48.
	CustomerOrderFieldPhotoURL48 = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.PhotoURL48, nil
		},
		column: customer.FieldPhotoURL48,
		toTerm: customer.ByPhotoURL48,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.PhotoURL48,
			}
		},
	}
	// CustomerOrderFieldPhotoURL72 orders Customer by photo_url_72.
	CustomerOrderFieldPhotoURL72 = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.PhotoURL72, nil
		},
		column: customer.FieldPhotoURL72,
		toTerm: customer.ByPhotoURL72,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.PhotoURL72,
			}
		},
	}
	// CustomerOrderFieldPhotoURL192 orders Customer by photo_url_192.
	CustomerOrderFieldPhotoURL192 = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.PhotoURL192, nil
		},
		column: customer.FieldPhotoURL192,
		toTerm: customer.ByPhotoURL192,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.PhotoURL192,
			}
		},
	}
	// CustomerOrderFieldPhotoURL512 orders Customer by photo_url_512.
	CustomerOrderFieldPhotoURL512 = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.PhotoURL512, nil
		},
		column: customer.FieldPhotoURL512,
		toTerm: customer.ByPhotoURL512,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.PhotoURL512,
			}
		},
	}
	// CustomerOrderFieldTimezone orders Customer by timezone.
	CustomerOrderFieldTimezone = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.Timezone, nil
		},
		column: customer.FieldTimezone,
		toTerm: customer.ByTimezone,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Timezone,
			}
		},
	}
	// CustomerOrderFieldLocale orders Customer by locale.
	CustomerOrderFieldLocale = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.Locale, nil
		},
		column: customer.FieldLocale,
		toTerm: customer.ByLocale,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Locale,
			}
		},
	}
	// CustomerOrderFieldCreatedAt orders Customer by created_at.
	CustomerOrderFieldCreatedAt = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: customer.FieldCreatedAt,
		toTerm: customer.ByCreatedAt,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// CustomerOrderFieldModifiedAt orders Customer by modified_at.
	CustomerOrderFieldModifiedAt = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.ModifiedAt, nil
		},
		column: customer.FieldModifiedAt,
		toTerm: customer.ByModifiedAt,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.ModifiedAt,
			}
		},
	}
	// CustomerOrderFieldDeletedAt orders Customer by deleted_at.
	CustomerOrderFieldDeletedAt = &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.DeletedAt, nil
		},
		column: customer.FieldDeletedAt,
		toTerm: customer.ByDeletedAt,
		toCursor: func(c *Customer) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomerOrderField) String() string {
	var str string
	switch f.column {
	case CustomerOrderFieldID.column:
		str = "id"
	case CustomerOrderFieldDesignation.column:
		str = "designation"
	case CustomerOrderFieldTitle.column:
		str = "title"
	case CustomerOrderFieldName.column:
		str = "name"
	case CustomerOrderFieldGivenName.column:
		str = "givenName"
	case CustomerOrderFieldMiddleName.column:
		str = "middleName"
	case CustomerOrderFieldFamilyName.column:
		str = "familyName"
	case CustomerOrderFieldPhotoURL.column:
		str = "photoUrl"
	case CustomerOrderFieldPhotoURL24.column:
		str = "photoUrl24"
	case CustomerOrderFieldPhotoURL32.column:
		str = "photoUrl32"
	case CustomerOrderFieldPhotoURL48.column:
		str = "photoUrl48"
	case CustomerOrderFieldPhotoURL72.column:
		str = "photoUrl72"
	case CustomerOrderFieldPhotoURL192.column:
		str = "photoUrl192"
	case CustomerOrderFieldPhotoURL512.column:
		str = "photoUrl512"
	case CustomerOrderFieldTimezone.column:
		str = "timezone"
	case CustomerOrderFieldLocale.column:
		str = "locale"
	case CustomerOrderFieldCreatedAt.column:
		str = "createdAt"
	case CustomerOrderFieldModifiedAt.column:
		str = "modifiedAt"
	case CustomerOrderFieldDeletedAt.column:
		str = "deletedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomerOrderField %T must be a string", v)
	}
	switch str {
	case "id":
		*f = *CustomerOrderFieldID
	case "designation":
		*f = *CustomerOrderFieldDesignation
	case "title":
		*f = *CustomerOrderFieldTitle
	case "name":
		*f = *CustomerOrderFieldName
	case "givenName":
		*f = *CustomerOrderFieldGivenName
	case "middleName":
		*f = *CustomerOrderFieldMiddleName
	case "familyName":
		*f = *CustomerOrderFieldFamilyName
	case "photoUrl":
		*f = *CustomerOrderFieldPhotoURL
	case "photoUrl24":
		*f = *CustomerOrderFieldPhotoURL24
	case "photoUrl32":
		*f = *CustomerOrderFieldPhotoURL32
	case "photoUrl48":
		*f = *CustomerOrderFieldPhotoURL48
	case "photoUrl72":
		*f = *CustomerOrderFieldPhotoURL72
	case "photoUrl192":
		*f = *CustomerOrderFieldPhotoURL192
	case "photoUrl512":
		*f = *CustomerOrderFieldPhotoURL512
	case "timezone":
		*f = *CustomerOrderFieldTimezone
	case "locale":
		*f = *CustomerOrderFieldLocale
	case "createdAt":
		*f = *CustomerOrderFieldCreatedAt
	case "modifiedAt":
		*f = *CustomerOrderFieldModifiedAt
	case "deletedAt":
		*f = *CustomerOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid CustomerOrderField", str)
	}
	return nil
}

// CustomerOrderField defines the ordering field of Customer.
type CustomerOrderField struct {
	// Value extracts the ordering value from the given Customer.
	Value    func(*Customer) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) customer.OrderOption
	toCursor func(*Customer) Cursor
}

// CustomerOrder defines the ordering of Customer.
type CustomerOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *CustomerOrderField `json:"field"`
}

// DefaultCustomerOrder is the default ordering of Customer.
var DefaultCustomerOrder = &CustomerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CustomerOrderField{
		Value: func(c *Customer) (ent.Value, error) {
			return c.ID, nil
		},
		column: customer.FieldID,
		toTerm: customer.ByID,
		toCursor: func(c *Customer) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Customer into CustomerEdge.
func (c *Customer) ToEdge(order *CustomerOrder) *CustomerEdge {
	if order == nil {
		order = DefaultCustomerOrder
	}
	return &CustomerEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CustomerOutboxEdge is the edge representation of CustomerOutbox.
type CustomerOutboxEdge struct {
	Node   *CustomerOutbox `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// CustomerOutboxConnection is the connection containing edges to CustomerOutbox.
type CustomerOutboxConnection struct {
	Edges      []*CustomerOutboxEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *CustomerOutboxConnection) build(nodes []*CustomerOutbox, pager *customeroutboxPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CustomerOutbox
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CustomerOutbox {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CustomerOutbox {
			return nodes[i]
		}
	}
	c.Edges = make([]*CustomerOutboxEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CustomerOutboxEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CustomerOutboxPaginateOption enables pagination customization.
type CustomerOutboxPaginateOption func(*customeroutboxPager) error

// WithCustomerOutboxOrder configures pagination ordering.
func WithCustomerOutboxOrder(order *CustomerOutboxOrder) CustomerOutboxPaginateOption {
	if order == nil {
		order = DefaultCustomerOutboxOrder
	}
	o := *order
	return func(pager *customeroutboxPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCustomerOutboxOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCustomerOutboxFilter configures pagination filter.
func WithCustomerOutboxFilter(filter func(*CustomerOutboxQuery) (*CustomerOutboxQuery, error)) CustomerOutboxPaginateOption {
	return func(pager *customeroutboxPager) error {
		if filter == nil {
			return errors.New("CustomerOutboxQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customeroutboxPager struct {
	reverse bool
	order   *CustomerOutboxOrder
	filter  func(*CustomerOutboxQuery) (*CustomerOutboxQuery, error)
}

func newCustomerOutboxPager(opts []CustomerOutboxPaginateOption, reverse bool) (*customeroutboxPager, error) {
	pager := &customeroutboxPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCustomerOutboxOrder
	}
	return pager, nil
}

func (p *customeroutboxPager) applyFilter(query *CustomerOutboxQuery) (*CustomerOutboxQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customeroutboxPager) toCursor(co *CustomerOutbox) Cursor {
	return p.order.Field.toCursor(co)
}

func (p *customeroutboxPager) applyCursors(query *CustomerOutboxQuery, after, before *Cursor) (*CustomerOutboxQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCustomerOutboxOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *customeroutboxPager) applyOrder(query *CustomerOutboxQuery) *CustomerOutboxQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCustomerOutboxOrder.Field {
		query = query.Order(DefaultCustomerOutboxOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *customeroutboxPager) orderExpr(query *CustomerOutboxQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCustomerOutboxOrder.Field {
			b.Comma().Ident(DefaultCustomerOutboxOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CustomerOutbox.
func (co *CustomerOutboxQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomerOutboxPaginateOption,
) (*CustomerOutboxConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomerOutboxPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if co, err = pager.applyFilter(co); err != nil {
		return nil, err
	}
	conn := &CustomerOutboxConnection{Edges: []*CustomerOutboxEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = co.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if co, err = pager.applyCursors(co, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		co.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := co.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	co = pager.applyOrder(co)
	nodes, err := co.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CustomerOutboxOrderFieldID orders CustomerOutbox by id.
	CustomerOutboxOrderFieldID = &CustomerOutboxOrderField{
		Value: func(co *CustomerOutbox) (ent.Value, error) {
			return co.ID, nil
		},
		column: customeroutbox.FieldID,
		toTerm: customeroutbox.ByID,
		toCursor: func(co *CustomerOutbox) Cursor {
			return Cursor{
				ID:    co.ID,
				Value: co.ID,
			}
		},
	}
	// CustomerOutboxOrderFieldStatus orders CustomerOutbox by status.
	CustomerOutboxOrderFieldStatus = &CustomerOutboxOrderField{
		Value: func(co *CustomerOutbox) (ent.Value, error) {
			return co.Status, nil
		},
		column: customeroutbox.FieldStatus,
		toTerm: customeroutbox.ByStatus,
		toCursor: func(co *CustomerOutbox) Cursor {
			return Cursor{
				ID:    co.ID,
				Value: co.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomerOutboxOrderField) String() string {
	var str string
	switch f.column {
	case CustomerOutboxOrderFieldID.column:
		str = "id"
	case CustomerOutboxOrderFieldStatus.column:
		str = "status"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomerOutboxOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomerOutboxOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomerOutboxOrderField %T must be a string", v)
	}
	switch str {
	case "id":
		*f = *CustomerOutboxOrderFieldID
	case "status":
		*f = *CustomerOutboxOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid CustomerOutboxOrderField", str)
	}
	return nil
}

// CustomerOutboxOrderField defines the ordering field of CustomerOutbox.
type CustomerOutboxOrderField struct {
	// Value extracts the ordering value from the given CustomerOutbox.
	Value    func(*CustomerOutbox) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) customeroutbox.OrderOption
	toCursor func(*CustomerOutbox) Cursor
}

// CustomerOutboxOrder defines the ordering of CustomerOutbox.
type CustomerOutboxOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *CustomerOutboxOrderField `json:"field"`
}

// DefaultCustomerOutboxOrder is the default ordering of CustomerOutbox.
var DefaultCustomerOutboxOrder = &CustomerOutboxOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CustomerOutboxOrderField{
		Value: func(co *CustomerOutbox) (ent.Value, error) {
			return co.ID, nil
		},
		column: customeroutbox.FieldID,
		toTerm: customeroutbox.ByID,
		toCursor: func(co *CustomerOutbox) Cursor {
			return Cursor{ID: co.ID}
		},
	},
}

// ToEdge converts CustomerOutbox into CustomerOutboxEdge.
func (co *CustomerOutbox) ToEdge(order *CustomerOutboxOrder) *CustomerOutboxEdge {
	if order == nil {
		order = DefaultCustomerOutboxOrder
	}
	return &CustomerOutboxEdge{
		Node:   co,
		Cursor: order.Field.toCursor(co),
	}
}

// CustomerSettingEdge is the edge representation of CustomerSetting.
type CustomerSettingEdge struct {
	Node   *CustomerSetting `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// CustomerSettingConnection is the connection containing edges to CustomerSetting.
type CustomerSettingConnection struct {
	Edges      []*CustomerSettingEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *CustomerSettingConnection) build(nodes []*CustomerSetting, pager *customersettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CustomerSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CustomerSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CustomerSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*CustomerSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CustomerSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CustomerSettingPaginateOption enables pagination customization.
type CustomerSettingPaginateOption func(*customersettingPager) error

// WithCustomerSettingOrder configures pagination ordering.
func WithCustomerSettingOrder(order *CustomerSettingOrder) CustomerSettingPaginateOption {
	if order == nil {
		order = DefaultCustomerSettingOrder
	}
	o := *order
	return func(pager *customersettingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCustomerSettingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCustomerSettingFilter configures pagination filter.
func WithCustomerSettingFilter(filter func(*CustomerSettingQuery) (*CustomerSettingQuery, error)) CustomerSettingPaginateOption {
	return func(pager *customersettingPager) error {
		if filter == nil {
			return errors.New("CustomerSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customersettingPager struct {
	reverse bool
	order   *CustomerSettingOrder
	filter  func(*CustomerSettingQuery) (*CustomerSettingQuery, error)
}

func newCustomerSettingPager(opts []CustomerSettingPaginateOption, reverse bool) (*customersettingPager, error) {
	pager := &customersettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCustomerSettingOrder
	}
	return pager, nil
}

func (p *customersettingPager) applyFilter(query *CustomerSettingQuery) (*CustomerSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customersettingPager) toCursor(cs *CustomerSetting) Cursor {
	return p.order.Field.toCursor(cs)
}

func (p *customersettingPager) applyCursors(query *CustomerSettingQuery, after, before *Cursor) (*CustomerSettingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCustomerSettingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *customersettingPager) applyOrder(query *CustomerSettingQuery) *CustomerSettingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCustomerSettingOrder.Field {
		query = query.Order(DefaultCustomerSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *customersettingPager) orderExpr(query *CustomerSettingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCustomerSettingOrder.Field {
			b.Comma().Ident(DefaultCustomerSettingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CustomerSetting.
func (cs *CustomerSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomerSettingPaginateOption,
) (*CustomerSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomerSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cs, err = pager.applyFilter(cs); err != nil {
		return nil, err
	}
	conn := &CustomerSettingConnection{Edges: []*CustomerSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = cs.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cs, err = pager.applyCursors(cs, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		cs.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cs.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cs = pager.applyOrder(cs)
	nodes, err := cs.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CustomerSettingOrderFieldID orders CustomerSetting by id.
	CustomerSettingOrderFieldID = &CustomerSettingOrderField{
		Value: func(cs *CustomerSetting) (ent.Value, error) {
			return cs.ID, nil
		},
		column: customersetting.FieldID,
		toTerm: customersetting.ByID,
		toCursor: func(cs *CustomerSetting) Cursor {
			return Cursor{
				ID:    cs.ID,
				Value: cs.ID,
			}
		},
	}
	// CustomerSettingOrderFieldCreatedAt orders CustomerSetting by created_at.
	CustomerSettingOrderFieldCreatedAt = &CustomerSettingOrderField{
		Value: func(cs *CustomerSetting) (ent.Value, error) {
			return cs.CreatedAt, nil
		},
		column: customersetting.FieldCreatedAt,
		toTerm: customersetting.ByCreatedAt,
		toCursor: func(cs *CustomerSetting) Cursor {
			return Cursor{
				ID:    cs.ID,
				Value: cs.CreatedAt,
			}
		},
	}
	// CustomerSettingOrderFieldModifiedAt orders CustomerSetting by modified_at.
	CustomerSettingOrderFieldModifiedAt = &CustomerSettingOrderField{
		Value: func(cs *CustomerSetting) (ent.Value, error) {
			return cs.ModifiedAt, nil
		},
		column: customersetting.FieldModifiedAt,
		toTerm: customersetting.ByModifiedAt,
		toCursor: func(cs *CustomerSetting) Cursor {
			return Cursor{
				ID:    cs.ID,
				Value: cs.ModifiedAt,
			}
		},
	}
	// CustomerSettingOrderFieldDeletedAt orders CustomerSetting by deleted_at.
	CustomerSettingOrderFieldDeletedAt = &CustomerSettingOrderField{
		Value: func(cs *CustomerSetting) (ent.Value, error) {
			return cs.DeletedAt, nil
		},
		column: customersetting.FieldDeletedAt,
		toTerm: customersetting.ByDeletedAt,
		toCursor: func(cs *CustomerSetting) Cursor {
			return Cursor{
				ID:    cs.ID,
				Value: cs.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomerSettingOrderField) String() string {
	var str string
	switch f.column {
	case CustomerSettingOrderFieldID.column:
		str = "id"
	case CustomerSettingOrderFieldCreatedAt.column:
		str = "createdAt"
	case CustomerSettingOrderFieldModifiedAt.column:
		str = "modifiedAt"
	case CustomerSettingOrderFieldDeletedAt.column:
		str = "deletedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomerSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomerSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomerSettingOrderField %T must be a string", v)
	}
	switch str {
	case "id":
		*f = *CustomerSettingOrderFieldID
	case "createdAt":
		*f = *CustomerSettingOrderFieldCreatedAt
	case "modifiedAt":
		*f = *CustomerSettingOrderFieldModifiedAt
	case "deletedAt":
		*f = *CustomerSettingOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid CustomerSettingOrderField", str)
	}
	return nil
}

// CustomerSettingOrderField defines the ordering field of CustomerSetting.
type CustomerSettingOrderField struct {
	// Value extracts the ordering value from the given CustomerSetting.
	Value    func(*CustomerSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) customersetting.OrderOption
	toCursor func(*CustomerSetting) Cursor
}

// CustomerSettingOrder defines the ordering of CustomerSetting.
type CustomerSettingOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *CustomerSettingOrderField `json:"field"`
}

// DefaultCustomerSettingOrder is the default ordering of CustomerSetting.
var DefaultCustomerSettingOrder = &CustomerSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CustomerSettingOrderField{
		Value: func(cs *CustomerSetting) (ent.Value, error) {
			return cs.ID, nil
		},
		column: customersetting.FieldID,
		toTerm: customersetting.ByID,
		toCursor: func(cs *CustomerSetting) Cursor {
			return Cursor{ID: cs.ID}
		},
	},
}

// ToEdge converts CustomerSetting into CustomerSettingEdge.
func (cs *CustomerSetting) ToEdge(order *CustomerSettingOrder) *CustomerSettingEdge {
	if order == nil {
		order = DefaultCustomerSettingOrder
	}
	return &CustomerSettingEdge{
		Node:   cs,
		Cursor: order.Field.toCursor(cs),
	}
}

// IdentityEdge is the edge representation of Identity.
type IdentityEdge struct {
	Node   *Identity `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// IdentityConnection is the connection containing edges to Identity.
type IdentityConnection struct {
	Edges      []*IdentityEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *IdentityConnection) build(nodes []*Identity, pager *identityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Identity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Identity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Identity {
			return nodes[i]
		}
	}
	c.Edges = make([]*IdentityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IdentityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IdentityPaginateOption enables pagination customization.
type IdentityPaginateOption func(*identityPager) error

// WithIdentityOrder configures pagination ordering.
func WithIdentityOrder(order *IdentityOrder) IdentityPaginateOption {
	if order == nil {
		order = DefaultIdentityOrder
	}
	o := *order
	return func(pager *identityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIdentityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIdentityFilter configures pagination filter.
func WithIdentityFilter(filter func(*IdentityQuery) (*IdentityQuery, error)) IdentityPaginateOption {
	return func(pager *identityPager) error {
		if filter == nil {
			return errors.New("IdentityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type identityPager struct {
	reverse bool
	order   *IdentityOrder
	filter  func(*IdentityQuery) (*IdentityQuery, error)
}

func newIdentityPager(opts []IdentityPaginateOption, reverse bool) (*identityPager, error) {
	pager := &identityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIdentityOrder
	}
	return pager, nil
}

func (p *identityPager) applyFilter(query *IdentityQuery) (*IdentityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *identityPager) toCursor(i *Identity) Cursor {
	return p.order.Field.toCursor(i)
}

func (p *identityPager) applyCursors(query *IdentityQuery, after, before *Cursor) (*IdentityQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultIdentityOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *identityPager) applyOrder(query *IdentityQuery) *IdentityQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultIdentityOrder.Field {
		query = query.Order(DefaultIdentityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *identityPager) orderExpr(query *IdentityQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultIdentityOrder.Field {
			b.Comma().Ident(DefaultIdentityOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Identity.
func (i *IdentityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IdentityPaginateOption,
) (*IdentityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIdentityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &IdentityConnection{Edges: []*IdentityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = i.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// IdentityOrderFieldID orders Identity by id.
	IdentityOrderFieldID = &IdentityOrderField{
		Value: func(i *Identity) (ent.Value, error) {
			return i.ID, nil
		},
		column: identity.FieldID,
		toTerm: identity.ByID,
		toCursor: func(i *Identity) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.ID,
			}
		},
	}
	// IdentityOrderFieldEmail orders Identity by email.
	IdentityOrderFieldEmail = &IdentityOrderField{
		Value: func(i *Identity) (ent.Value, error) {
			return i.Email, nil
		},
		column: identity.FieldEmail,
		toTerm: identity.ByEmail,
		toCursor: func(i *Identity) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Email,
			}
		},
	}
	// IdentityOrderFieldEmailVerified orders Identity by email_verified.
	IdentityOrderFieldEmailVerified = &IdentityOrderField{
		Value: func(i *Identity) (ent.Value, error) {
			return i.EmailVerified, nil
		},
		column: identity.FieldEmailVerified,
		toTerm: identity.ByEmailVerified,
		toCursor: func(i *Identity) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.EmailVerified,
			}
		},
	}
	// IdentityOrderFieldCreatedAt orders Identity by created_at.
	IdentityOrderFieldCreatedAt = &IdentityOrderField{
		Value: func(i *Identity) (ent.Value, error) {
			return i.CreatedAt, nil
		},
		column: identity.FieldCreatedAt,
		toTerm: identity.ByCreatedAt,
		toCursor: func(i *Identity) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.CreatedAt,
			}
		},
	}
	// IdentityOrderFieldModifiedAt orders Identity by modified_at.
	IdentityOrderFieldModifiedAt = &IdentityOrderField{
		Value: func(i *Identity) (ent.Value, error) {
			return i.ModifiedAt, nil
		},
		column: identity.FieldModifiedAt,
		toTerm: identity.ByModifiedAt,
		toCursor: func(i *Identity) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.ModifiedAt,
			}
		},
	}
	// IdentityOrderFieldDeletedAt orders Identity by deleted_at.
	IdentityOrderFieldDeletedAt = &IdentityOrderField{
		Value: func(i *Identity) (ent.Value, error) {
			return i.DeletedAt, nil
		},
		column: identity.FieldDeletedAt,
		toTerm: identity.ByDeletedAt,
		toCursor: func(i *Identity) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f IdentityOrderField) String() string {
	var str string
	switch f.column {
	case IdentityOrderFieldID.column:
		str = "id"
	case IdentityOrderFieldEmail.column:
		str = "email"
	case IdentityOrderFieldEmailVerified.column:
		str = "emailVerified"
	case IdentityOrderFieldCreatedAt.column:
		str = "createdAt"
	case IdentityOrderFieldModifiedAt.column:
		str = "modifiedAt"
	case IdentityOrderFieldDeletedAt.column:
		str = "deletedAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f IdentityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *IdentityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("IdentityOrderField %T must be a string", v)
	}
	switch str {
	case "id":
		*f = *IdentityOrderFieldID
	case "email":
		*f = *IdentityOrderFieldEmail
	case "emailVerified":
		*f = *IdentityOrderFieldEmailVerified
	case "createdAt":
		*f = *IdentityOrderFieldCreatedAt
	case "modifiedAt":
		*f = *IdentityOrderFieldModifiedAt
	case "deletedAt":
		*f = *IdentityOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid IdentityOrderField", str)
	}
	return nil
}

// IdentityOrderField defines the ordering field of Identity.
type IdentityOrderField struct {
	// Value extracts the ordering value from the given Identity.
	Value    func(*Identity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) identity.OrderOption
	toCursor func(*Identity) Cursor
}

// IdentityOrder defines the ordering of Identity.
type IdentityOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *IdentityOrderField `json:"field"`
}

// DefaultIdentityOrder is the default ordering of Identity.
var DefaultIdentityOrder = &IdentityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IdentityOrderField{
		Value: func(i *Identity) (ent.Value, error) {
			return i.ID, nil
		},
		column: identity.FieldID,
		toTerm: identity.ByID,
		toCursor: func(i *Identity) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Identity into IdentityEdge.
func (i *Identity) ToEdge(order *IdentityOrder) *IdentityEdge {
	if order == nil {
		order = DefaultIdentityOrder
	}
	return &IdentityEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}
