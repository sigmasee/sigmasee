// Package apexinvestmentsv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package apexinvestmentsv1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// BalanceBreakdownResponse defines model for BalanceBreakdownResponse.
type BalanceBreakdownResponse struct {
	Items *[]BalanceBreakdownResponseItem `json:"items"`
}

// BalanceBreakdownResponseItem defines model for BalanceBreakdownResponseItem.
type BalanceBreakdownResponseItem struct {
	Amount      *float64 `json:"amount,omitempty"`
	Description *string  `json:"description"`
	FundCode    *string  `json:"fundCode"`
}

// FmcaInvestmentMixResponse defines model for FmcaInvestmentMixResponse.
type FmcaInvestmentMixResponse struct {
	FmcaDate *time.Time                       `json:"fmcaDate,omitempty"`
	Items    *[]FmcaInvestmentMixResponseItem `json:"items"`
}

// FmcaInvestmentMixResponseItem defines model for FmcaInvestmentMixResponseItem.
type FmcaInvestmentMixResponseItem struct {
	FmcaAssetClass  *string  `json:"fmcaAssetClass"`
	FundCode        *string  `json:"fundCode"`
	Percentage      *float64 `json:"percentage,omitempty"`
	SectorValueBase *float64 `json:"sectorValueBase,omitempty"`
}

// FmcaTopAssetsResponse defines model for FmcaTopAssetsResponse.
type FmcaTopAssetsResponse struct {
	FmcaDate *time.Time                   `json:"fmcaDate,omitempty"`
	Items    *[]FmcaTopAssetsResponseItem `json:"items"`
}

// FmcaTopAssetsResponseItem defines model for FmcaTopAssetsResponseItem.
type FmcaTopAssetsResponseItem struct {
	AssetName              *string   `json:"assetName"`
	FmcaAssetClass         *string   `json:"fmcaAssetClass"`
	FmcaAssetType          *string   `json:"fmcaAssetType"`
	Funds                  *[]string `json:"funds"`
	InvestorAssetValueBase *float64  `json:"investorAssetValueBase,omitempty"`
	Percentage             *float64  `json:"percentage,omitempty"`
}

// FundPriceDatesResponse defines model for FundPriceDatesResponse.
type FundPriceDatesResponse struct {
	Items *[]FundPriceDatesResponseItem `json:"items"`
}

// FundPriceDatesResponseItem defines model for FundPriceDatesResponseItem.
type FundPriceDatesResponseItem struct {
	FundCode    *string    `json:"fundCode"`
	MaximumDate *time.Time `json:"maximumDate,omitempty"`
	MinimumDate *time.Time `json:"minimumDate,omitempty"`
}

// FundRiskResponse defines model for FundRiskResponse.
type FundRiskResponse struct {
	Frequency *string    `json:"frequency"`
	FromDate  *time.Time `json:"fromDate,omitempty"`
	FundCode  *string    `json:"fundCode"`
	Risk      *float64   `json:"risk,omitempty"`
	ToDate    *time.Time `json:"toDate,omitempty"`
}

// FundVolatilityResponse defines model for FundVolatilityResponse.
type FundVolatilityResponse struct {
	Frequency  *string    `json:"frequency"`
	FromDate   *time.Time `json:"fromDate,omitempty"`
	FundCode   *string    `json:"fundCode"`
	ToDate     *time.Time `json:"toDate,omitempty"`
	Volatility *float64   `json:"volatility,omitempty"`
}

// GainsResponse defines model for GainsResponse.
type GainsResponse struct {
	Value *float64 `json:"value"`
}

// InceptionDateResponse defines model for InceptionDateResponse.
type InceptionDateResponse struct {
	Date *time.Time `json:"date,omitempty"`
}

// Investment defines model for Investment.
type Investment struct {
	CloseDate          *time.Time          `json:"closeDate"`
	Code               *string             `json:"code"`
	DistributionMethod *string             `json:"distributionMethod"`
	FeeRate            *float64            `json:"feeRate"`
	Id                 *openapi_types.UUID `json:"id,omitempty"`
	InceptionDate      *time.Time          `json:"inceptionDate,omitempty"`
	MasterClient       *string             `json:"masterClient"`
	Metadata           *interface{}        `json:"metadata"`
	Name               *string             `json:"name"`
	PrimaryInvestorId  *openapi_types.UUID `json:"primaryInvestorId,omitempty"`
	Status             *string             `json:"status"`
	Type               *string             `json:"type"`
}

// InvestmentBankAccount defines model for InvestmentBankAccount.
type InvestmentBankAccount struct {
	AccountNumber   *float64   `json:"accountNumber"`
	BankAccountName *string    `json:"bankAccountName"`
	BankCode        *float64   `json:"bankCode"`
	BranchCode      *float64   `json:"branchCode"`
	IsPrimary       *bool      `json:"isPrimary,omitempty"`
	Suffix          *float64   `json:"suffix"`
	WhenCreatedUtc  *time.Time `json:"whenCreatedUtc"`
}

// InvestmentBankAccountsResponse defines model for InvestmentBankAccountsResponse.
type InvestmentBankAccountsResponse struct {
	Items *[]InvestmentBankAccount `json:"items"`
}

// InvestmentHolding defines model for InvestmentHolding.
type InvestmentHolding struct {
	Code  *string  `json:"code"`
	Name  *string  `json:"name"`
	Price *float64 `json:"price"`
	Units *float64 `json:"units,omitempty"`
}

// InvestmentHoldingsResponse defines model for InvestmentHoldingsResponse.
type InvestmentHoldingsResponse struct {
	Items *[]InvestmentHolding `json:"items"`
}

// InvestmentTotalValueResponse defines model for InvestmentTotalValueResponse.
type InvestmentTotalValueResponse struct {
	InvestmentId *openapi_types.UUID `json:"investmentId,omitempty"`
	TotalValue   *float64            `json:"totalValue"`
}

// InvestmentsPagedResponse defines model for InvestmentsPagedResponse.
type InvestmentsPagedResponse struct {
	Items  *[]Investment `json:"items"`
	Paging *Paging       `json:"paging,omitempty"`
}

// InvestmentsTotalValuePagedResponse defines model for InvestmentsTotalValuePagedResponse.
type InvestmentsTotalValuePagedResponse struct {
	Items  *[]InvestmentTotalValueResponse `json:"items"`
	Paging *Paging                         `json:"paging,omitempty"`
}

// InvestorTotalValueResponse defines model for InvestorTotalValueResponse.
type InvestorTotalValueResponse struct {
	InvestmentCount *float64            `json:"investmentCount"`
	InvestorId      *openapi_types.UUID `json:"investorId,omitempty"`
	TotalValue      *float64            `json:"totalValue"`
}

// InvestorsTotalValuePagedResponse defines model for InvestorsTotalValuePagedResponse.
type InvestorsTotalValuePagedResponse struct {
	Items  *[]InvestorTotalValueResponse `json:"items"`
	Paging *Paging                       `json:"paging,omitempty"`
}

// LatestPriceDateResponse defines model for LatestPriceDateResponse.
type LatestPriceDateResponse struct {
	Date *time.Time `json:"date,omitempty"`
}

// NetReturnResponse defines model for NetReturnResponse.
type NetReturnResponse struct {
	NetReturn *float64 `json:"netReturn,omitempty"`
}

// NetReturnSeriesItem defines model for NetReturnSeriesItem.
type NetReturnSeriesItem struct {
	EndDate   *string  `json:"endDate"`
	NetReturn *float64 `json:"netReturn"`
	StartDate *string  `json:"startDate"`
}

// NetReturnSeriesResponse defines model for NetReturnSeriesResponse.
type NetReturnSeriesResponse struct {
	Items *[]NetReturnSeriesItem `json:"items"`
}

// Paging defines model for Paging.
type Paging struct {
	After  *string `json:"after"`
	Before *string `json:"before"`
	Total  *int32  `json:"total"`
}

// PendingTransactionResponseItem defines model for PendingTransactionResponseItem.
type PendingTransactionResponseItem struct {
	Amount        *float64            `json:"amount"`
	AmountType    *string             `json:"amountType"`
	EffectiveDate *time.Time          `json:"effectiveDate,omitempty"`
	FundCode      *string             `json:"fundCode"`
	FundName      *string             `json:"fundName"`
	InvestmentId  *openapi_types.UUID `json:"investmentId,omitempty"`
}

// PendingTransactionsResponse defines model for PendingTransactionsResponse.
type PendingTransactionsResponse struct {
	Items *[]PendingTransactionResponseItem `json:"items"`
}

// StandingInstructionResponseItem defines model for StandingInstructionResponseItem.
type StandingInstructionResponseItem struct {
	Amount                  *float64            `json:"amount,omitempty"`
	AmountType              *string             `json:"amountType"`
	BankAccountId           *float64            `json:"bankAccountId,omitempty"`
	CalendarFrequency       *float64            `json:"calendarFrequency,omitempty"`
	CalendarName            *string             `json:"calendarName"`
	FundCode                *string             `json:"fundCode"`
	InvestmentId            *openapi_types.UUID `json:"investmentId,omitempty"`
	LastRunDate             *time.Time          `json:"lastRunDate,omitempty"`
	NextRunDate             *time.Time          `json:"nextRunDate,omitempty"`
	StandingInstructionId   *float64            `json:"standingInstructionId,omitempty"`
	StandingInstructionType *string             `json:"standingInstructionType"`
}

// StandingInstructionsResponse defines model for StandingInstructionsResponse.
type StandingInstructionsResponse struct {
	Items *[]StandingInstructionResponseItem `json:"items"`
}

// SystemIOStream defines model for System.IO.Stream.
type SystemIOStream struct {
	CanRead      *bool  `json:"canRead,omitempty"`
	CanSeek      *bool  `json:"canSeek,omitempty"`
	CanTimeout   *bool  `json:"canTimeout,omitempty"`
	CanWrite     *bool  `json:"canWrite,omitempty"`
	Length       *int64 `json:"length,omitempty"`
	Position     *int64 `json:"position,omitempty"`
	ReadTimeout  *int32 `json:"readTimeout,omitempty"`
	WriteTimeout *int32 `json:"writeTimeout,omitempty"`
}

// TargetFundAllocationResponse defines model for TargetFundAllocationResponse.
type TargetFundAllocationResponse struct {
	Items *[]TargetFundAllocationResponseItem `json:"items"`
}

// TargetFundAllocationResponseItem defines model for TargetFundAllocationResponseItem.
type TargetFundAllocationResponseItem struct {
	FundCode   *string  `json:"fundCode"`
	FundName   *string  `json:"fundName"`
	Percentage *float64 `json:"percentage,omitempty"`
}

// TotalValueSeriesItem defines model for TotalValueSeriesItem.
type TotalValueSeriesItem struct {
	Date       *string  `json:"date"`
	TotalValue *float64 `json:"totalValue"`
}

// TotalValueSeriesResponse defines model for TotalValueSeriesResponse.
type TotalValueSeriesResponse struct {
	Items *[]TotalValueSeriesItem `json:"items"`
}

// TransactionHighlightsResponse defines model for TransactionHighlightsResponse.
type TransactionHighlightsResponse struct {
	CashDistributions       *float64 `json:"cashDistributions,omitempty"`
	Contributions           *float64 `json:"contributions"`
	Fees                    *float64 `json:"fees"`
	ReinvestedDistributions *float64 `json:"reinvestedDistributions"`
	Tax                     *float64 `json:"tax"`
	Withdrawals             *float64 `json:"withdrawals"`
}

// TransactionResponseItem defines model for TransactionResponseItem.
type TransactionResponseItem struct {
	AccruedIncome                    *float64            `json:"accruedIncome"`
	Amount                           *float64            `json:"amount"`
	Cash                             *float64            `json:"cash"`
	CashClearing                     *float64            `json:"cashClearing"`
	Description                      *string             `json:"description"`
	EffectiveDate                    *time.Time          `json:"effectiveDate,omitempty"`
	Fee                              *float64            `json:"fee"`
	FormulatedTransactionDescription *string             `json:"formulatedTransactionDescription"`
	FundCode                         *string             `json:"fundCode"`
	FundName                         *string             `json:"fundName"`
	InvestmentId                     *openapi_types.UUID `json:"investmentId,omitempty"`
	PaymentClearing                  *float64            `json:"paymentClearing"`
	Price                            *float64            `json:"price"`
	Tax                              *float64            `json:"tax"`
	TaxRebate                        *float64            `json:"taxRebate"`
	TransactionContext               *string             `json:"transactionContext"`
	TransactionId                    *float64            `json:"transactionId,omitempty"`
	TransactionMethod                *string             `json:"transactionMethod"`
	TransactionReason                *string             `json:"transactionReason"`
	TransactionSource                *string             `json:"transactionSource"`
	TransactionSubtype               *string             `json:"transactionSubtype"`
	TransactionType                  *string             `json:"transactionType"`
	Units                            *float64            `json:"units"`
}

// TransactionsPagedResponse defines model for TransactionsPagedResponse.
type TransactionsPagedResponse struct {
	Items *[]TransactionResponseItem `json:"items"`
}

// UnitPriceSeriesItem defines model for UnitPriceSeriesItem.
type UnitPriceSeriesItem struct {
	Date      *string  `json:"date"`
	UnitPrice *float64 `json:"unitPrice"`
}

// UnitPriceSeriesResponse defines model for UnitPriceSeriesResponse.
type UnitPriceSeriesResponse struct {
	Items *[]UnitPriceSeriesItem `json:"items"`
}

// GetFmcaTopAssetsParams defines parameters for GetFmcaTopAssets.
type GetFmcaTopAssetsParams struct {
	// Date Date on which to retrieve the holdings
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Fund If provided, restricts the asset list to assets held by the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`

	// Limit The maximum number of assets to return. Defaults to 10.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// IncludeNegativeAssets When true, assets with a negative value are included in the response. Defaults to false.
	IncludeNegativeAssets *bool `form:"includeNegativeAssets,omitempty" json:"includeNegativeAssets,omitempty"`
}

// GetFundUnitPriceSeriesParams defines parameters for GetFundUnitPriceSeries.
type GetFundUnitPriceSeriesParams struct {
	// StartDate Start date for unit price series. If not provided, the date range queried will start from the earliest price for the fund.
	StartDate *time.Time `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for unit price series. If not provided, the date range queried will end at the latest price for the fund.
	EndDate *time.Time `form:"endDate,omitempty" json:"endDate,omitempty"`
}

// GetGainsParams defines parameters for GetGains.
type GetGainsParams struct {
	// FromDate Start date for the gains calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the gains calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the gains calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetPagedInvestmentsParams defines parameters for GetPagedInvestments.
type GetPagedInvestmentsParams struct {
	// Limit The maximum number of objects that may be returned. Defaults to the maximum of 1000. A result list with fewer items than the specified limit is not a guarantee that the end of the data has been reached. To determine if another page exists, check for a \"before\" or \"after\" value on the response. \"Before\" indicates a previous page exists and \"after\" indicates a subsequent page exists.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// After If provided, the page returned will begin with the item after this one. To page forwards, you can set this value to the \"after\" property of a previous response. This parameter is mutually exclusive with the before parameter.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before If provided, the page returned will end with the item before this one. To page backwards, you can set this value to the \"before\" property of a previous response. This parameter is mutually exclusive with the after parameter.
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// InvestmentCode If provided, the investments will be filtered by investment code.
	InvestmentCode *string `form:"investmentCode,omitempty" json:"investmentCode,omitempty"`
}

// GetPagedInvestmentTotalValuesParams defines parameters for GetPagedInvestmentTotalValues.
type GetPagedInvestmentTotalValuesParams struct {
	// Date The date for which the total value will be calculated.
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Limit The maximum number of objects that may be returned. Defaults to the maximum of 1000. A result list with fewer items than the specified limit is not a guarantee that the end of the data has been reached. To determine if another page exists, check for a \"before\" or \"after\" value on the response. \"Before\" indicates a previous page exists and \"after\" indicates a subsequent page exists.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// After If provided, the page returned will begin with the item after this one. To page forwards, you can set this value to the \"after\" property of a previous response. This parameter is mutually exclusive with the before parameter.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before If provided, the page returned will end with the item before this one. To page backwards, you can set this value to the \"before\" property of a previous response. This parameter is mutually exclusive with the after parameter.
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// GetFmcaInvestmentMixParams defines parameters for GetFmcaInvestmentMix.
type GetFmcaInvestmentMixParams struct {
	// Date Date on which to retrieve the holdings
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Fund If provided, restricts the asset list to assets held by the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetInvestmentFmcaTopAssetsParams defines parameters for GetInvestmentFmcaTopAssets.
type GetInvestmentFmcaTopAssetsParams struct {
	// Date Date on which to retrieve the holdings
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Fund If provided, restricts the asset list to assets held by the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`

	// Limit The maximum number of assets to return. Defaults to 10.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// IncludeNegativeAssets When true, assets with a negative value are included in the response. Defaults to false.
	IncludeNegativeAssets *bool `form:"includeNegativeAssets,omitempty" json:"includeNegativeAssets,omitempty"`
}

// GetInvestmentFundsParams defines parameters for GetInvestmentFunds.
type GetInvestmentFundsParams struct {
	// Date Date for which to retrieve holdings and prices
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`
}

// GetInvestmentGainsParams defines parameters for GetInvestmentGains.
type GetInvestmentGainsParams struct {
	// FromDate Start date for the gains calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the gains calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the gains calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetInvestmentNetReturnParams defines parameters for GetInvestmentNetReturn.
type GetInvestmentNetReturnParams struct {
	// FromDate Start date for the net return calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the net return calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund If provided, restricts the net return calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetInvestmentNetReturnSeriesParams defines parameters for GetInvestmentNetReturnSeries.
type GetInvestmentNetReturnSeriesParams struct {
	// Dates A comma-separated list of dates to be used as the start and end dates for the net return calculation. The earliest date will be the start date for every period, and each other date will be the end date for a single period.
	Dates *string `form:"dates,omitempty" json:"dates,omitempty"`

	// Fund If provided, restricts the net return calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetInvestmentPendingTransactionsParams defines parameters for GetInvestmentPendingTransactions.
type GetInvestmentPendingTransactionsParams struct {
	// FromDate The earliest acceptable effective date for returned transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetInvestmentTotalValueParams defines parameters for GetInvestmentTotalValue.
type GetInvestmentTotalValueParams struct {
	// Date The date for which the total value will be calculated.
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Fund If provided, restricts the total value calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetInvestmentTotalValueSeriesParams defines parameters for GetInvestmentTotalValueSeries.
type GetInvestmentTotalValueSeriesParams struct {
	// Dates A comma-separated list of dates for which the total value will be calculated.
	Dates *string `form:"dates,omitempty" json:"dates,omitempty"`

	// Fund If provided, restricts the total value calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetPagedInvestmentTransactionsParams defines parameters for GetPagedInvestmentTransactions.
type GetPagedInvestmentTransactionsParams struct {
	// FromDate The earliest acceptable effective date for returned transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetInvestmentTransactionBalanceBreakdownParams defines parameters for GetInvestmentTransactionBalanceBreakdown.
type GetInvestmentTransactionBalanceBreakdownParams struct {
	// FromDate Start date for the balance breakdown
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the balance breakdown
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund If provided, restricts the net return calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`

	// GroupingType If provided, changes the grouping of the transactions and description. KiwiSaverDefault, RetailDefault, MixDefault.
	GroupingType *string `form:"groupingType,omitempty" json:"groupingType,omitempty"`

	// GroupByFund If provided, the balance breakdowns are grouped by fund cod
	GroupByFund *bool `form:"groupByFund,omitempty" json:"groupByFund,omitempty"`
}

// GetInvestmentTransactionsCsvParams defines parameters for GetInvestmentTransactionsCsv.
type GetInvestmentTransactionsCsvParams struct {
	// FromDate The earliest acceptable effective date for returned transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetInvestmentTransactionHighlightsParams defines parameters for GetInvestmentTransactionHighlights.
type GetInvestmentTransactionHighlightsParams struct {
	// FromDate Start date for the highlights calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the highlights calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the highlights calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetPagedInvestorTotalValuesParams defines parameters for GetPagedInvestorTotalValues.
type GetPagedInvestorTotalValuesParams struct {
	// Date The date for which the total value will be calculated.
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Limit The maximum number of objects that may be returned. Defaults to the maximum of 1000. A result list with fewer items than the specified limit is not a guarantee that the end of the data has been reached. To determine if another page exists, check for a \"before\" or \"after\" value on the response. \"Before\" indicates a previous page exists and \"after\" indicates a subsequent page exists.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// After If provided, the page returned will begin with the item after this one. To page forwards, you can set this value to the \"after\" property of a previous response. This parameter is mutually exclusive with the before parameter.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before If provided, the page returned will end with the item before this one. To page backwards, you can set this value to the \"before\" property of a previous response. This parameter is mutually exclusive with the after parameter.
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// GetInvestorFmcaTopAssetsParams defines parameters for GetInvestorFmcaTopAssets.
type GetInvestorFmcaTopAssetsParams struct {
	// Date Date on which to retrieve the holdings
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Fund If provided, restricts the asset list to assets held by the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`

	// Limit The maximum number of assets to return. Defaults to 10.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// IncludeNegativeAssets When true, assets with a negative value are included in the response. Defaults to false.
	IncludeNegativeAssets *bool `form:"includeNegativeAssets,omitempty" json:"includeNegativeAssets,omitempty"`
}

// GetInvestorGainsParams defines parameters for GetInvestorGains.
type GetInvestorGainsParams struct {
	// FromDate Start date for the gains calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the gains calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the gains calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetPagedInvestorInvestmentsParams defines parameters for GetPagedInvestorInvestments.
type GetPagedInvestorInvestmentsParams struct {
	// Limit The maximum number of objects that may be returned. Defaults to the maximum of 1000. A result list with fewer items than the specified limit is not a guarantee that the end of the data has been reached. To determine if another page exists, check for a \"before\" or \"after\" value on the response. \"Before\" indicates a previous page exists and \"after\" indicates a subsequent page exists.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// After If provided, the page returned will begin with the item after this one. To page forwards, you can set this value to the \"after\" property of a previous response. This parameter is mutually exclusive with the before parameter.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before If provided, the page returned will end with the item before this one. To page backwards, you can set this value to the \"before\" property of a previous response. This parameter is mutually exclusive with the after parameter.
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// GetInvestorNetReturnParams defines parameters for GetInvestorNetReturn.
type GetInvestorNetReturnParams struct {
	// FromDate Start date for the net return calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the net return calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the net return calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetInvestorPendingTransactionsParams defines parameters for GetInvestorPendingTransactions.
type GetInvestorPendingTransactionsParams struct {
	// FromDate The earliest acceptable effective date for returned pending transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned pending transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetInvestorTotalValueParams defines parameters for GetInvestorTotalValue.
type GetInvestorTotalValueParams struct {
	// Date The date for which the total value will be calculated.
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`
}

// GetPagedInvestorTransactionsParams defines parameters for GetPagedInvestorTransactions.
type GetPagedInvestorTransactionsParams struct {
	// FromDate The earliest acceptable effective date for returned transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Type If provided, filters the results to the specific transaction type, i.e. \"APP\", \"WDW\", \"FEE\"
	Type *string `form:"type,omitempty" json:"type,omitempty"`
}

// GetInvestorTransactionBalanceBreakdownParams defines parameters for GetInvestorTransactionBalanceBreakdown.
type GetInvestorTransactionBalanceBreakdownParams struct {
	// FromDate Start date for the balance breakdown
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the balance breakdown
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund If provided, restricts the net return calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`

	// GroupingType If provided, changes the grouping of the transactions and description. KiwiSaverDefault, RetailDefault, MixDefault.
	GroupingType *string `form:"groupingType,omitempty" json:"groupingType,omitempty"`
}

// GetInvestorTransactionHighlightsParams defines parameters for GetInvestorTransactionHighlights.
type GetInvestorTransactionHighlightsParams struct {
	// FromDate Start date for the highlights calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the highlights calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the highlights calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetNetReturnSeriesParams defines parameters for GetNetReturnSeries.
type GetNetReturnSeriesParams struct {
	// Dates A comma-separated list of dates to be used as the start and end dates for the net return calculation. The earliest date will be the start date for every period, and each other date will be the end date for a single period.
	Dates *string `form:"dates,omitempty" json:"dates,omitempty"`

	// Fund If provided, restricts the net return calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetPendingTransactionsParams defines parameters for GetPendingTransactions.
type GetPendingTransactionsParams struct {
	// FromDate The earliest acceptable effective date for returned pending transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned pending transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetTotalValueParams defines parameters for GetTotalValue.
type GetTotalValueParams struct {
	// Date The date for which the total value will be calculated.
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Fund If provided, restricts the total value calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetTotalValueSeriesParams defines parameters for GetTotalValueSeries.
type GetTotalValueSeriesParams struct {
	// Dates A comma-separated list of dates for which the total value will be calculated.
	Dates *string `form:"dates,omitempty" json:"dates,omitempty"`

	// Fund If provided, restricts the total value calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetPagedTransactionsParams defines parameters for GetPagedTransactions.
type GetPagedTransactionsParams struct {
	// FromDate The earliest acceptable effective date for returned transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetTransactionBalanceBreakdownParams defines parameters for GetTransactionBalanceBreakdown.
type GetTransactionBalanceBreakdownParams struct {
	// FromDate Start date for the balance breakdown
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the balance breakdown
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund If provided, restricts the net return calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`

	// GroupingType If provided, changes the grouping of the transactions and description. KiwiSaverDefault, RetailDefault, MixDefault.
	GroupingType *string `form:"groupingType,omitempty" json:"groupingType,omitempty"`
}

// GetTransactionHighlightsParams defines parameters for GetTransactionHighlights.
type GetTransactionHighlightsParams struct {
	// FromDate Start date for the highlights calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the highlights calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the highlights calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetFmcaTopAssets request
	GetFmcaTopAssets(ctx context.Context, params *GetFmcaTopAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundRisk request
	GetFundRisk(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundUnitPriceSeries request
	GetFundUnitPriceSeries(ctx context.Context, code string, params *GetFundUnitPriceSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundVolatility request
	GetFundVolatility(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGains request
	GetGains(ctx context.Context, params *GetGainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInceptionDate request
	GetInceptionDate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPagedInvestments request
	GetPagedInvestments(ctx context.Context, params *GetPagedInvestmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPagedInvestmentTotalValues request
	GetPagedInvestmentTotalValues(ctx context.Context, params *GetPagedInvestmentTotalValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestment request
	GetInvestment(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentBankAccounts request
	GetInvestmentBankAccounts(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFmcaInvestmentMix request
	GetFmcaInvestmentMix(ctx context.Context, id openapi_types.UUID, params *GetFmcaInvestmentMixParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentFmcaTopAssets request
	GetInvestmentFmcaTopAssets(ctx context.Context, id openapi_types.UUID, params *GetInvestmentFmcaTopAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentFunds request
	GetInvestmentFunds(ctx context.Context, id openapi_types.UUID, params *GetInvestmentFundsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentGains request
	GetInvestmentGains(ctx context.Context, id openapi_types.UUID, params *GetInvestmentGainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentNetReturn request
	GetInvestmentNetReturn(ctx context.Context, id openapi_types.UUID, params *GetInvestmentNetReturnParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentNetReturnSeries request
	GetInvestmentNetReturnSeries(ctx context.Context, id openapi_types.UUID, params *GetInvestmentNetReturnSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentPendingTransactions request
	GetInvestmentPendingTransactions(ctx context.Context, id openapi_types.UUID, params *GetInvestmentPendingTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentsFundsPriceDates request
	GetInvestmentsFundsPriceDates(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentStandingInstructions request
	GetInvestmentStandingInstructions(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentTargetFundAllocation request
	GetInvestmentTargetFundAllocation(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentTotalValue request
	GetInvestmentTotalValue(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTotalValueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentTotalValueSeries request
	GetInvestmentTotalValueSeries(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTotalValueSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPagedInvestmentTransactions request
	GetPagedInvestmentTransactions(ctx context.Context, id openapi_types.UUID, params *GetPagedInvestmentTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentTransactionBalanceBreakdown request
	GetInvestmentTransactionBalanceBreakdown(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTransactionBalanceBreakdownParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentTransactionsCsv request
	GetInvestmentTransactionsCsv(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTransactionsCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestmentTransactionHighlights request
	GetInvestmentTransactionHighlights(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTransactionHighlightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPagedInvestorTotalValues request
	GetPagedInvestorTotalValues(ctx context.Context, params *GetPagedInvestorTotalValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestorFmcaTopAssets request
	GetInvestorFmcaTopAssets(ctx context.Context, id openapi_types.UUID, params *GetInvestorFmcaTopAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestorGains request
	GetInvestorGains(ctx context.Context, id openapi_types.UUID, params *GetInvestorGainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestorInceptionDate request
	GetInvestorInceptionDate(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPagedInvestorInvestments request
	GetPagedInvestorInvestments(ctx context.Context, id openapi_types.UUID, params *GetPagedInvestorInvestmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestorNetReturn request
	GetInvestorNetReturn(ctx context.Context, id openapi_types.UUID, params *GetInvestorNetReturnParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestorPendingTransactions request
	GetInvestorPendingTransactions(ctx context.Context, id openapi_types.UUID, params *GetInvestorPendingTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestorStandingInstructions request
	GetInvestorStandingInstructions(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestorTotalValue request
	GetInvestorTotalValue(ctx context.Context, id openapi_types.UUID, params *GetInvestorTotalValueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPagedInvestorTransactions request
	GetPagedInvestorTransactions(ctx context.Context, id openapi_types.UUID, params *GetPagedInvestorTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestorTransactionBalanceBreakdown request
	GetInvestorTransactionBalanceBreakdown(ctx context.Context, id openapi_types.UUID, params *GetInvestorTransactionBalanceBreakdownParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvestorTransactionHighlights request
	GetInvestorTransactionHighlights(ctx context.Context, id openapi_types.UUID, params *GetInvestorTransactionHighlightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestPriceDate request
	GetLatestPriceDate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetReturnSeries request
	GetNetReturnSeries(ctx context.Context, params *GetNetReturnSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPendingTransactions request
	GetPendingTransactions(ctx context.Context, params *GetPendingTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStandingInstructions request
	GetStandingInstructions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTotalValue request
	GetTotalValue(ctx context.Context, params *GetTotalValueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTotalValueSeries request
	GetTotalValueSeries(ctx context.Context, params *GetTotalValueSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPagedTransactions request
	GetPagedTransactions(ctx context.Context, params *GetPagedTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionBalanceBreakdown request
	GetTransactionBalanceBreakdown(ctx context.Context, params *GetTransactionBalanceBreakdownParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionHighlights request
	GetTransactionHighlights(ctx context.Context, params *GetTransactionHighlightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetFmcaTopAssets(ctx context.Context, params *GetFmcaTopAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFmcaTopAssetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundRisk(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundRiskRequest(c.Server, code)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundUnitPriceSeries(ctx context.Context, code string, params *GetFundUnitPriceSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundUnitPriceSeriesRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundVolatility(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundVolatilityRequest(c.Server, code)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGains(ctx context.Context, params *GetGainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGainsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInceptionDate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInceptionDateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPagedInvestments(ctx context.Context, params *GetPagedInvestmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPagedInvestmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPagedInvestmentTotalValues(ctx context.Context, params *GetPagedInvestmentTotalValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPagedInvestmentTotalValuesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestment(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentBankAccounts(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentBankAccountsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFmcaInvestmentMix(ctx context.Context, id openapi_types.UUID, params *GetFmcaInvestmentMixParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFmcaInvestmentMixRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentFmcaTopAssets(ctx context.Context, id openapi_types.UUID, params *GetInvestmentFmcaTopAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentFmcaTopAssetsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentFunds(ctx context.Context, id openapi_types.UUID, params *GetInvestmentFundsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentFundsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentGains(ctx context.Context, id openapi_types.UUID, params *GetInvestmentGainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentGainsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentNetReturn(ctx context.Context, id openapi_types.UUID, params *GetInvestmentNetReturnParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentNetReturnRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentNetReturnSeries(ctx context.Context, id openapi_types.UUID, params *GetInvestmentNetReturnSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentNetReturnSeriesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentPendingTransactions(ctx context.Context, id openapi_types.UUID, params *GetInvestmentPendingTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentPendingTransactionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentsFundsPriceDates(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentsFundsPriceDatesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentStandingInstructions(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentStandingInstructionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentTargetFundAllocation(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentTargetFundAllocationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentTotalValue(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTotalValueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentTotalValueRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentTotalValueSeries(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTotalValueSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentTotalValueSeriesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPagedInvestmentTransactions(ctx context.Context, id openapi_types.UUID, params *GetPagedInvestmentTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPagedInvestmentTransactionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentTransactionBalanceBreakdown(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTransactionBalanceBreakdownParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentTransactionBalanceBreakdownRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentTransactionsCsv(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTransactionsCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentTransactionsCsvRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestmentTransactionHighlights(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTransactionHighlightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestmentTransactionHighlightsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPagedInvestorTotalValues(ctx context.Context, params *GetPagedInvestorTotalValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPagedInvestorTotalValuesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestorFmcaTopAssets(ctx context.Context, id openapi_types.UUID, params *GetInvestorFmcaTopAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestorFmcaTopAssetsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestorGains(ctx context.Context, id openapi_types.UUID, params *GetInvestorGainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestorGainsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestorInceptionDate(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestorInceptionDateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPagedInvestorInvestments(ctx context.Context, id openapi_types.UUID, params *GetPagedInvestorInvestmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPagedInvestorInvestmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestorNetReturn(ctx context.Context, id openapi_types.UUID, params *GetInvestorNetReturnParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestorNetReturnRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestorPendingTransactions(ctx context.Context, id openapi_types.UUID, params *GetInvestorPendingTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestorPendingTransactionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestorStandingInstructions(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestorStandingInstructionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestorTotalValue(ctx context.Context, id openapi_types.UUID, params *GetInvestorTotalValueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestorTotalValueRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPagedInvestorTransactions(ctx context.Context, id openapi_types.UUID, params *GetPagedInvestorTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPagedInvestorTransactionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestorTransactionBalanceBreakdown(ctx context.Context, id openapi_types.UUID, params *GetInvestorTransactionBalanceBreakdownParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestorTransactionBalanceBreakdownRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvestorTransactionHighlights(ctx context.Context, id openapi_types.UUID, params *GetInvestorTransactionHighlightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvestorTransactionHighlightsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestPriceDate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestPriceDateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetReturnSeries(ctx context.Context, params *GetNetReturnSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetReturnSeriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPendingTransactions(ctx context.Context, params *GetPendingTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPendingTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStandingInstructions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStandingInstructionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTotalValue(ctx context.Context, params *GetTotalValueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTotalValueRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTotalValueSeries(ctx context.Context, params *GetTotalValueSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTotalValueSeriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPagedTransactions(ctx context.Context, params *GetPagedTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPagedTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionBalanceBreakdown(ctx context.Context, params *GetTransactionBalanceBreakdownParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionBalanceBreakdownRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionHighlights(ctx context.Context, params *GetTransactionHighlightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionHighlightsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetFmcaTopAssetsRequest generates requests for GetFmcaTopAssets
func NewGetFmcaTopAssetsRequest(server string, params *GetFmcaTopAssetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fmca-top-assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeNegativeAssets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeNegativeAssets", runtime.ParamLocationQuery, *params.IncludeNegativeAssets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundRiskRequest generates requests for GetFundRisk
func NewGetFundRiskRequest(server string, code string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/funds/%s/risk", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundUnitPriceSeriesRequest generates requests for GetFundUnitPriceSeries
func NewGetFundUnitPriceSeriesRequest(server string, code string, params *GetFundUnitPriceSeriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/funds/%s/unit-price-series", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundVolatilityRequest generates requests for GetFundVolatility
func NewGetFundVolatilityRequest(server string, code string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/funds/%s/volatility", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGainsRequest generates requests for GetGains
func NewGetGainsRequest(server string, params *GetGainsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInceptionDateRequest generates requests for GetInceptionDate
func NewGetInceptionDateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inception-date")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPagedInvestmentsRequest generates requests for GetPagedInvestments
func NewGetPagedInvestmentsRequest(server string, params *GetPagedInvestmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InvestmentCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "investmentCode", runtime.ParamLocationQuery, *params.InvestmentCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPagedInvestmentTotalValuesRequest generates requests for GetPagedInvestmentTotalValues
func NewGetPagedInvestmentTotalValuesRequest(server string, params *GetPagedInvestmentTotalValuesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/total-values")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentRequest generates requests for GetInvestment
func NewGetInvestmentRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentBankAccountsRequest generates requests for GetInvestmentBankAccounts
func NewGetInvestmentBankAccountsRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/bank-accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFmcaInvestmentMixRequest generates requests for GetFmcaInvestmentMix
func NewGetFmcaInvestmentMixRequest(server string, id openapi_types.UUID, params *GetFmcaInvestmentMixParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/fmca-investment-mix", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentFmcaTopAssetsRequest generates requests for GetInvestmentFmcaTopAssets
func NewGetInvestmentFmcaTopAssetsRequest(server string, id openapi_types.UUID, params *GetInvestmentFmcaTopAssetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/fmca-top-assets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeNegativeAssets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeNegativeAssets", runtime.ParamLocationQuery, *params.IncludeNegativeAssets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentFundsRequest generates requests for GetInvestmentFunds
func NewGetInvestmentFundsRequest(server string, id openapi_types.UUID, params *GetInvestmentFundsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/funds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentGainsRequest generates requests for GetInvestmentGains
func NewGetInvestmentGainsRequest(server string, id openapi_types.UUID, params *GetInvestmentGainsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/gains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentNetReturnRequest generates requests for GetInvestmentNetReturn
func NewGetInvestmentNetReturnRequest(server string, id openapi_types.UUID, params *GetInvestmentNetReturnParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/net-return", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentNetReturnSeriesRequest generates requests for GetInvestmentNetReturnSeries
func NewGetInvestmentNetReturnSeriesRequest(server string, id openapi_types.UUID, params *GetInvestmentNetReturnSeriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/net-return-series", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Dates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dates", runtime.ParamLocationQuery, *params.Dates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentPendingTransactionsRequest generates requests for GetInvestmentPendingTransactions
func NewGetInvestmentPendingTransactionsRequest(server string, id openapi_types.UUID, params *GetInvestmentPendingTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/pending-transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentsFundsPriceDatesRequest generates requests for GetInvestmentsFundsPriceDates
func NewGetInvestmentsFundsPriceDatesRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/price-dates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentStandingInstructionsRequest generates requests for GetInvestmentStandingInstructions
func NewGetInvestmentStandingInstructionsRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/standing-instructions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentTargetFundAllocationRequest generates requests for GetInvestmentTargetFundAllocation
func NewGetInvestmentTargetFundAllocationRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/target-fund-allocation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentTotalValueRequest generates requests for GetInvestmentTotalValue
func NewGetInvestmentTotalValueRequest(server string, id openapi_types.UUID, params *GetInvestmentTotalValueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/total-value", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentTotalValueSeriesRequest generates requests for GetInvestmentTotalValueSeries
func NewGetInvestmentTotalValueSeriesRequest(server string, id openapi_types.UUID, params *GetInvestmentTotalValueSeriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/total-value-series", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Dates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dates", runtime.ParamLocationQuery, *params.Dates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPagedInvestmentTransactionsRequest generates requests for GetPagedInvestmentTransactions
func NewGetPagedInvestmentTransactionsRequest(server string, id openapi_types.UUID, params *GetPagedInvestmentTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentTransactionBalanceBreakdownRequest generates requests for GetInvestmentTransactionBalanceBreakdown
func NewGetInvestmentTransactionBalanceBreakdownRequest(server string, id openapi_types.UUID, params *GetInvestmentTransactionBalanceBreakdownParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/transactions/balance-breakdown", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupingType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupingType", runtime.ParamLocationQuery, *params.GroupingType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupByFund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupByFund", runtime.ParamLocationQuery, *params.GroupByFund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentTransactionsCsvRequest generates requests for GetInvestmentTransactionsCsv
func NewGetInvestmentTransactionsCsvRequest(server string, id openapi_types.UUID, params *GetInvestmentTransactionsCsvParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/transactions/csv", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestmentTransactionHighlightsRequest generates requests for GetInvestmentTransactionHighlights
func NewGetInvestmentTransactionHighlightsRequest(server string, id openapi_types.UUID, params *GetInvestmentTransactionHighlightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investments/%s/transactions/highlights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPagedInvestorTotalValuesRequest generates requests for GetPagedInvestorTotalValues
func NewGetPagedInvestorTotalValuesRequest(server string, params *GetPagedInvestorTotalValuesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investors/total-values")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestorFmcaTopAssetsRequest generates requests for GetInvestorFmcaTopAssets
func NewGetInvestorFmcaTopAssetsRequest(server string, id openapi_types.UUID, params *GetInvestorFmcaTopAssetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investors/%s/fmca-top-assets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeNegativeAssets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeNegativeAssets", runtime.ParamLocationQuery, *params.IncludeNegativeAssets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestorGainsRequest generates requests for GetInvestorGains
func NewGetInvestorGainsRequest(server string, id openapi_types.UUID, params *GetInvestorGainsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investors/%s/gains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestorInceptionDateRequest generates requests for GetInvestorInceptionDate
func NewGetInvestorInceptionDateRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investors/%s/inception-date", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPagedInvestorInvestmentsRequest generates requests for GetPagedInvestorInvestments
func NewGetPagedInvestorInvestmentsRequest(server string, id openapi_types.UUID, params *GetPagedInvestorInvestmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investors/%s/investments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestorNetReturnRequest generates requests for GetInvestorNetReturn
func NewGetInvestorNetReturnRequest(server string, id openapi_types.UUID, params *GetInvestorNetReturnParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investors/%s/net-return", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestorPendingTransactionsRequest generates requests for GetInvestorPendingTransactions
func NewGetInvestorPendingTransactionsRequest(server string, id openapi_types.UUID, params *GetInvestorPendingTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investors/%s/pending-transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestorStandingInstructionsRequest generates requests for GetInvestorStandingInstructions
func NewGetInvestorStandingInstructionsRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investors/%s/standing-instructions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestorTotalValueRequest generates requests for GetInvestorTotalValue
func NewGetInvestorTotalValueRequest(server string, id openapi_types.UUID, params *GetInvestorTotalValueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investors/%s/total-value", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPagedInvestorTransactionsRequest generates requests for GetPagedInvestorTransactions
func NewGetPagedInvestorTransactionsRequest(server string, id openapi_types.UUID, params *GetPagedInvestorTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investors/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestorTransactionBalanceBreakdownRequest generates requests for GetInvestorTransactionBalanceBreakdown
func NewGetInvestorTransactionBalanceBreakdownRequest(server string, id openapi_types.UUID, params *GetInvestorTransactionBalanceBreakdownParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investors/%s/transactions/balance-breakdown", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupingType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupingType", runtime.ParamLocationQuery, *params.GroupingType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvestorTransactionHighlightsRequest generates requests for GetInvestorTransactionHighlights
func NewGetInvestorTransactionHighlightsRequest(server string, id openapi_types.UUID, params *GetInvestorTransactionHighlightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/investors/%s/transactions/highlights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLatestPriceDateRequest generates requests for GetLatestPriceDate
func NewGetLatestPriceDateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/latest-price-date")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetReturnSeriesRequest generates requests for GetNetReturnSeries
func NewGetNetReturnSeriesRequest(server string, params *GetNetReturnSeriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/net-return-series")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Dates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dates", runtime.ParamLocationQuery, *params.Dates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPendingTransactionsRequest generates requests for GetPendingTransactions
func NewGetPendingTransactionsRequest(server string, params *GetPendingTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pending-transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStandingInstructionsRequest generates requests for GetStandingInstructions
func NewGetStandingInstructionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/standing-instructions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTotalValueRequest generates requests for GetTotalValue
func NewGetTotalValueRequest(server string, params *GetTotalValueParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/total-value")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTotalValueSeriesRequest generates requests for GetTotalValueSeries
func NewGetTotalValueSeriesRequest(server string, params *GetTotalValueSeriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/total-value-series")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Dates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dates", runtime.ParamLocationQuery, *params.Dates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPagedTransactionsRequest generates requests for GetPagedTransactions
func NewGetPagedTransactionsRequest(server string, params *GetPagedTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionBalanceBreakdownRequest generates requests for GetTransactionBalanceBreakdown
func NewGetTransactionBalanceBreakdownRequest(server string, params *GetTransactionBalanceBreakdownParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/balance-breakdown")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupingType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupingType", runtime.ParamLocationQuery, *params.GroupingType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionHighlightsRequest generates requests for GetTransactionHighlights
func NewGetTransactionHighlightsRequest(server string, params *GetTransactionHighlightsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/highlights")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromDate", runtime.ParamLocationQuery, *params.FromDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toDate", runtime.ParamLocationQuery, *params.ToDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fund != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fund", runtime.ParamLocationQuery, *params.Fund); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetFmcaTopAssetsWithResponse request
	GetFmcaTopAssetsWithResponse(ctx context.Context, params *GetFmcaTopAssetsParams, reqEditors ...RequestEditorFn) (*GetFmcaTopAssetsResponse, error)

	// GetFundRiskWithResponse request
	GetFundRiskWithResponse(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*GetFundRiskResponse, error)

	// GetFundUnitPriceSeriesWithResponse request
	GetFundUnitPriceSeriesWithResponse(ctx context.Context, code string, params *GetFundUnitPriceSeriesParams, reqEditors ...RequestEditorFn) (*GetFundUnitPriceSeriesResponse, error)

	// GetFundVolatilityWithResponse request
	GetFundVolatilityWithResponse(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*GetFundVolatilityResponse, error)

	// GetGainsWithResponse request
	GetGainsWithResponse(ctx context.Context, params *GetGainsParams, reqEditors ...RequestEditorFn) (*GetGainsResponse, error)

	// GetInceptionDateWithResponse request
	GetInceptionDateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInceptionDateResponse, error)

	// GetPagedInvestmentsWithResponse request
	GetPagedInvestmentsWithResponse(ctx context.Context, params *GetPagedInvestmentsParams, reqEditors ...RequestEditorFn) (*GetPagedInvestmentsResponse, error)

	// GetPagedInvestmentTotalValuesWithResponse request
	GetPagedInvestmentTotalValuesWithResponse(ctx context.Context, params *GetPagedInvestmentTotalValuesParams, reqEditors ...RequestEditorFn) (*GetPagedInvestmentTotalValuesResponse, error)

	// GetInvestmentWithResponse request
	GetInvestmentWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestmentResponse, error)

	// GetInvestmentBankAccountsWithResponse request
	GetInvestmentBankAccountsWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestmentBankAccountsResponse, error)

	// GetFmcaInvestmentMixWithResponse request
	GetFmcaInvestmentMixWithResponse(ctx context.Context, id openapi_types.UUID, params *GetFmcaInvestmentMixParams, reqEditors ...RequestEditorFn) (*GetFmcaInvestmentMixResponse, error)

	// GetInvestmentFmcaTopAssetsWithResponse request
	GetInvestmentFmcaTopAssetsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentFmcaTopAssetsParams, reqEditors ...RequestEditorFn) (*GetInvestmentFmcaTopAssetsResponse, error)

	// GetInvestmentFundsWithResponse request
	GetInvestmentFundsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentFundsParams, reqEditors ...RequestEditorFn) (*GetInvestmentFundsResponse, error)

	// GetInvestmentGainsWithResponse request
	GetInvestmentGainsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentGainsParams, reqEditors ...RequestEditorFn) (*GetInvestmentGainsResponse, error)

	// GetInvestmentNetReturnWithResponse request
	GetInvestmentNetReturnWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentNetReturnParams, reqEditors ...RequestEditorFn) (*GetInvestmentNetReturnResponse, error)

	// GetInvestmentNetReturnSeriesWithResponse request
	GetInvestmentNetReturnSeriesWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentNetReturnSeriesParams, reqEditors ...RequestEditorFn) (*GetInvestmentNetReturnSeriesResponse, error)

	// GetInvestmentPendingTransactionsWithResponse request
	GetInvestmentPendingTransactionsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentPendingTransactionsParams, reqEditors ...RequestEditorFn) (*GetInvestmentPendingTransactionsResponse, error)

	// GetInvestmentsFundsPriceDatesWithResponse request
	GetInvestmentsFundsPriceDatesWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestmentsFundsPriceDatesResponse, error)

	// GetInvestmentStandingInstructionsWithResponse request
	GetInvestmentStandingInstructionsWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestmentStandingInstructionsResponse, error)

	// GetInvestmentTargetFundAllocationWithResponse request
	GetInvestmentTargetFundAllocationWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestmentTargetFundAllocationResponse, error)

	// GetInvestmentTotalValueWithResponse request
	GetInvestmentTotalValueWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTotalValueParams, reqEditors ...RequestEditorFn) (*GetInvestmentTotalValueResponse, error)

	// GetInvestmentTotalValueSeriesWithResponse request
	GetInvestmentTotalValueSeriesWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTotalValueSeriesParams, reqEditors ...RequestEditorFn) (*GetInvestmentTotalValueSeriesResponse, error)

	// GetPagedInvestmentTransactionsWithResponse request
	GetPagedInvestmentTransactionsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetPagedInvestmentTransactionsParams, reqEditors ...RequestEditorFn) (*GetPagedInvestmentTransactionsResponse, error)

	// GetInvestmentTransactionBalanceBreakdownWithResponse request
	GetInvestmentTransactionBalanceBreakdownWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTransactionBalanceBreakdownParams, reqEditors ...RequestEditorFn) (*GetInvestmentTransactionBalanceBreakdownResponse, error)

	// GetInvestmentTransactionsCsvWithResponse request
	GetInvestmentTransactionsCsvWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTransactionsCsvParams, reqEditors ...RequestEditorFn) (*GetInvestmentTransactionsCsvResponse, error)

	// GetInvestmentTransactionHighlightsWithResponse request
	GetInvestmentTransactionHighlightsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTransactionHighlightsParams, reqEditors ...RequestEditorFn) (*GetInvestmentTransactionHighlightsResponse, error)

	// GetPagedInvestorTotalValuesWithResponse request
	GetPagedInvestorTotalValuesWithResponse(ctx context.Context, params *GetPagedInvestorTotalValuesParams, reqEditors ...RequestEditorFn) (*GetPagedInvestorTotalValuesResponse, error)

	// GetInvestorFmcaTopAssetsWithResponse request
	GetInvestorFmcaTopAssetsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorFmcaTopAssetsParams, reqEditors ...RequestEditorFn) (*GetInvestorFmcaTopAssetsResponse, error)

	// GetInvestorGainsWithResponse request
	GetInvestorGainsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorGainsParams, reqEditors ...RequestEditorFn) (*GetInvestorGainsResponse, error)

	// GetInvestorInceptionDateWithResponse request
	GetInvestorInceptionDateWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestorInceptionDateResponse, error)

	// GetPagedInvestorInvestmentsWithResponse request
	GetPagedInvestorInvestmentsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetPagedInvestorInvestmentsParams, reqEditors ...RequestEditorFn) (*GetPagedInvestorInvestmentsResponse, error)

	// GetInvestorNetReturnWithResponse request
	GetInvestorNetReturnWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorNetReturnParams, reqEditors ...RequestEditorFn) (*GetInvestorNetReturnResponse, error)

	// GetInvestorPendingTransactionsWithResponse request
	GetInvestorPendingTransactionsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorPendingTransactionsParams, reqEditors ...RequestEditorFn) (*GetInvestorPendingTransactionsResponse, error)

	// GetInvestorStandingInstructionsWithResponse request
	GetInvestorStandingInstructionsWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestorStandingInstructionsResponse, error)

	// GetInvestorTotalValueWithResponse request
	GetInvestorTotalValueWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorTotalValueParams, reqEditors ...RequestEditorFn) (*GetInvestorTotalValueResponse, error)

	// GetPagedInvestorTransactionsWithResponse request
	GetPagedInvestorTransactionsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetPagedInvestorTransactionsParams, reqEditors ...RequestEditorFn) (*GetPagedInvestorTransactionsResponse, error)

	// GetInvestorTransactionBalanceBreakdownWithResponse request
	GetInvestorTransactionBalanceBreakdownWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorTransactionBalanceBreakdownParams, reqEditors ...RequestEditorFn) (*GetInvestorTransactionBalanceBreakdownResponse, error)

	// GetInvestorTransactionHighlightsWithResponse request
	GetInvestorTransactionHighlightsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorTransactionHighlightsParams, reqEditors ...RequestEditorFn) (*GetInvestorTransactionHighlightsResponse, error)

	// GetLatestPriceDateWithResponse request
	GetLatestPriceDateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLatestPriceDateResponse, error)

	// GetNetReturnSeriesWithResponse request
	GetNetReturnSeriesWithResponse(ctx context.Context, params *GetNetReturnSeriesParams, reqEditors ...RequestEditorFn) (*GetNetReturnSeriesResponse, error)

	// GetPendingTransactionsWithResponse request
	GetPendingTransactionsWithResponse(ctx context.Context, params *GetPendingTransactionsParams, reqEditors ...RequestEditorFn) (*GetPendingTransactionsResponse, error)

	// GetStandingInstructionsWithResponse request
	GetStandingInstructionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStandingInstructionsResponse, error)

	// GetTotalValueWithResponse request
	GetTotalValueWithResponse(ctx context.Context, params *GetTotalValueParams, reqEditors ...RequestEditorFn) (*GetTotalValueResponse, error)

	// GetTotalValueSeriesWithResponse request
	GetTotalValueSeriesWithResponse(ctx context.Context, params *GetTotalValueSeriesParams, reqEditors ...RequestEditorFn) (*GetTotalValueSeriesResponse, error)

	// GetPagedTransactionsWithResponse request
	GetPagedTransactionsWithResponse(ctx context.Context, params *GetPagedTransactionsParams, reqEditors ...RequestEditorFn) (*GetPagedTransactionsResponse, error)

	// GetTransactionBalanceBreakdownWithResponse request
	GetTransactionBalanceBreakdownWithResponse(ctx context.Context, params *GetTransactionBalanceBreakdownParams, reqEditors ...RequestEditorFn) (*GetTransactionBalanceBreakdownResponse, error)

	// GetTransactionHighlightsWithResponse request
	GetTransactionHighlightsWithResponse(ctx context.Context, params *GetTransactionHighlightsParams, reqEditors ...RequestEditorFn) (*GetTransactionHighlightsResponse, error)
}

type GetFmcaTopAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FmcaTopAssetsResponse
}

// Status returns HTTPResponse.Status
func (r GetFmcaTopAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFmcaTopAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundRiskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FundRiskResponse
}

// Status returns HTTPResponse.Status
func (r GetFundRiskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundRiskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundUnitPriceSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UnitPriceSeriesResponse
}

// Status returns HTTPResponse.Status
func (r GetFundUnitPriceSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundUnitPriceSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundVolatilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FundVolatilityResponse
}

// Status returns HTTPResponse.Status
func (r GetFundVolatilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundVolatilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GainsResponse
}

// Status returns HTTPResponse.Status
func (r GetGainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInceptionDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InceptionDateResponse
}

// Status returns HTTPResponse.Status
func (r GetInceptionDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInceptionDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPagedInvestmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InvestmentsPagedResponse
}

// Status returns HTTPResponse.Status
func (r GetPagedInvestmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPagedInvestmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPagedInvestmentTotalValuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InvestmentsTotalValuePagedResponse
}

// Status returns HTTPResponse.Status
func (r GetPagedInvestmentTotalValuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPagedInvestmentTotalValuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Investment
}

// Status returns HTTPResponse.Status
func (r GetInvestmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentBankAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InvestmentBankAccountsResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentBankAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentBankAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFmcaInvestmentMixResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FmcaInvestmentMixResponse
}

// Status returns HTTPResponse.Status
func (r GetFmcaInvestmentMixResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFmcaInvestmentMixResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentFmcaTopAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FmcaTopAssetsResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentFmcaTopAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentFmcaTopAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentFundsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InvestmentHoldingsResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentFundsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentFundsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentGainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GainsResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentGainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentGainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentNetReturnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetReturnResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentNetReturnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentNetReturnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentNetReturnSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetReturnSeriesResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentNetReturnSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentNetReturnSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentPendingTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PendingTransactionsResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentPendingTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentPendingTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentsFundsPriceDatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FundPriceDatesResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentsFundsPriceDatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentsFundsPriceDatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentStandingInstructionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StandingInstructionsResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentStandingInstructionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentStandingInstructionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentTargetFundAllocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TargetFundAllocationResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentTargetFundAllocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentTargetFundAllocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentTotalValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InvestmentTotalValueResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentTotalValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentTotalValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentTotalValueSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TotalValueSeriesResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentTotalValueSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentTotalValueSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPagedInvestmentTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionsPagedResponse
}

// Status returns HTTPResponse.Status
func (r GetPagedInvestmentTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPagedInvestmentTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentTransactionBalanceBreakdownResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BalanceBreakdownResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentTransactionBalanceBreakdownResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentTransactionBalanceBreakdownResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentTransactionsCsvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SystemIOStream
}

// Status returns HTTPResponse.Status
func (r GetInvestmentTransactionsCsvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentTransactionsCsvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestmentTransactionHighlightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionHighlightsResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestmentTransactionHighlightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestmentTransactionHighlightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPagedInvestorTotalValuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InvestorsTotalValuePagedResponse
}

// Status returns HTTPResponse.Status
func (r GetPagedInvestorTotalValuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPagedInvestorTotalValuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestorFmcaTopAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FmcaTopAssetsResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestorFmcaTopAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestorFmcaTopAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestorGainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GainsResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestorGainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestorGainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestorInceptionDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InceptionDateResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestorInceptionDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestorInceptionDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPagedInvestorInvestmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InvestmentsPagedResponse
}

// Status returns HTTPResponse.Status
func (r GetPagedInvestorInvestmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPagedInvestorInvestmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestorNetReturnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetReturnResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestorNetReturnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestorNetReturnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestorPendingTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PendingTransactionsResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestorPendingTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestorPendingTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestorStandingInstructionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StandingInstructionsResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestorStandingInstructionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestorStandingInstructionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestorTotalValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InvestorTotalValueResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestorTotalValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestorTotalValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPagedInvestorTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionsPagedResponse
}

// Status returns HTTPResponse.Status
func (r GetPagedInvestorTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPagedInvestorTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestorTransactionBalanceBreakdownResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BalanceBreakdownResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestorTransactionBalanceBreakdownResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestorTransactionBalanceBreakdownResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvestorTransactionHighlightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionHighlightsResponse
}

// Status returns HTTPResponse.Status
func (r GetInvestorTransactionHighlightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvestorTransactionHighlightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestPriceDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LatestPriceDateResponse
}

// Status returns HTTPResponse.Status
func (r GetLatestPriceDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestPriceDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetReturnSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetReturnSeriesResponse
}

// Status returns HTTPResponse.Status
func (r GetNetReturnSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetReturnSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPendingTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PendingTransactionsResponse
}

// Status returns HTTPResponse.Status
func (r GetPendingTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPendingTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStandingInstructionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StandingInstructionsResponse
}

// Status returns HTTPResponse.Status
func (r GetStandingInstructionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStandingInstructionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTotalValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TotalValueSeriesItem
}

// Status returns HTTPResponse.Status
func (r GetTotalValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTotalValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTotalValueSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TotalValueSeriesResponse
}

// Status returns HTTPResponse.Status
func (r GetTotalValueSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTotalValueSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPagedTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionsPagedResponse
}

// Status returns HTTPResponse.Status
func (r GetPagedTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPagedTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionBalanceBreakdownResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BalanceBreakdownResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionBalanceBreakdownResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionBalanceBreakdownResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionHighlightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionHighlightsResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionHighlightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionHighlightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetFmcaTopAssetsWithResponse request returning *GetFmcaTopAssetsResponse
func (c *ClientWithResponses) GetFmcaTopAssetsWithResponse(ctx context.Context, params *GetFmcaTopAssetsParams, reqEditors ...RequestEditorFn) (*GetFmcaTopAssetsResponse, error) {
	rsp, err := c.GetFmcaTopAssets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFmcaTopAssetsResponse(rsp)
}

// GetFundRiskWithResponse request returning *GetFundRiskResponse
func (c *ClientWithResponses) GetFundRiskWithResponse(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*GetFundRiskResponse, error) {
	rsp, err := c.GetFundRisk(ctx, code, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundRiskResponse(rsp)
}

// GetFundUnitPriceSeriesWithResponse request returning *GetFundUnitPriceSeriesResponse
func (c *ClientWithResponses) GetFundUnitPriceSeriesWithResponse(ctx context.Context, code string, params *GetFundUnitPriceSeriesParams, reqEditors ...RequestEditorFn) (*GetFundUnitPriceSeriesResponse, error) {
	rsp, err := c.GetFundUnitPriceSeries(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundUnitPriceSeriesResponse(rsp)
}

// GetFundVolatilityWithResponse request returning *GetFundVolatilityResponse
func (c *ClientWithResponses) GetFundVolatilityWithResponse(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*GetFundVolatilityResponse, error) {
	rsp, err := c.GetFundVolatility(ctx, code, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundVolatilityResponse(rsp)
}

// GetGainsWithResponse request returning *GetGainsResponse
func (c *ClientWithResponses) GetGainsWithResponse(ctx context.Context, params *GetGainsParams, reqEditors ...RequestEditorFn) (*GetGainsResponse, error) {
	rsp, err := c.GetGains(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGainsResponse(rsp)
}

// GetInceptionDateWithResponse request returning *GetInceptionDateResponse
func (c *ClientWithResponses) GetInceptionDateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInceptionDateResponse, error) {
	rsp, err := c.GetInceptionDate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInceptionDateResponse(rsp)
}

// GetPagedInvestmentsWithResponse request returning *GetPagedInvestmentsResponse
func (c *ClientWithResponses) GetPagedInvestmentsWithResponse(ctx context.Context, params *GetPagedInvestmentsParams, reqEditors ...RequestEditorFn) (*GetPagedInvestmentsResponse, error) {
	rsp, err := c.GetPagedInvestments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPagedInvestmentsResponse(rsp)
}

// GetPagedInvestmentTotalValuesWithResponse request returning *GetPagedInvestmentTotalValuesResponse
func (c *ClientWithResponses) GetPagedInvestmentTotalValuesWithResponse(ctx context.Context, params *GetPagedInvestmentTotalValuesParams, reqEditors ...RequestEditorFn) (*GetPagedInvestmentTotalValuesResponse, error) {
	rsp, err := c.GetPagedInvestmentTotalValues(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPagedInvestmentTotalValuesResponse(rsp)
}

// GetInvestmentWithResponse request returning *GetInvestmentResponse
func (c *ClientWithResponses) GetInvestmentWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestmentResponse, error) {
	rsp, err := c.GetInvestment(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentResponse(rsp)
}

// GetInvestmentBankAccountsWithResponse request returning *GetInvestmentBankAccountsResponse
func (c *ClientWithResponses) GetInvestmentBankAccountsWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestmentBankAccountsResponse, error) {
	rsp, err := c.GetInvestmentBankAccounts(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentBankAccountsResponse(rsp)
}

// GetFmcaInvestmentMixWithResponse request returning *GetFmcaInvestmentMixResponse
func (c *ClientWithResponses) GetFmcaInvestmentMixWithResponse(ctx context.Context, id openapi_types.UUID, params *GetFmcaInvestmentMixParams, reqEditors ...RequestEditorFn) (*GetFmcaInvestmentMixResponse, error) {
	rsp, err := c.GetFmcaInvestmentMix(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFmcaInvestmentMixResponse(rsp)
}

// GetInvestmentFmcaTopAssetsWithResponse request returning *GetInvestmentFmcaTopAssetsResponse
func (c *ClientWithResponses) GetInvestmentFmcaTopAssetsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentFmcaTopAssetsParams, reqEditors ...RequestEditorFn) (*GetInvestmentFmcaTopAssetsResponse, error) {
	rsp, err := c.GetInvestmentFmcaTopAssets(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentFmcaTopAssetsResponse(rsp)
}

// GetInvestmentFundsWithResponse request returning *GetInvestmentFundsResponse
func (c *ClientWithResponses) GetInvestmentFundsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentFundsParams, reqEditors ...RequestEditorFn) (*GetInvestmentFundsResponse, error) {
	rsp, err := c.GetInvestmentFunds(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentFundsResponse(rsp)
}

// GetInvestmentGainsWithResponse request returning *GetInvestmentGainsResponse
func (c *ClientWithResponses) GetInvestmentGainsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentGainsParams, reqEditors ...RequestEditorFn) (*GetInvestmentGainsResponse, error) {
	rsp, err := c.GetInvestmentGains(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentGainsResponse(rsp)
}

// GetInvestmentNetReturnWithResponse request returning *GetInvestmentNetReturnResponse
func (c *ClientWithResponses) GetInvestmentNetReturnWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentNetReturnParams, reqEditors ...RequestEditorFn) (*GetInvestmentNetReturnResponse, error) {
	rsp, err := c.GetInvestmentNetReturn(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentNetReturnResponse(rsp)
}

// GetInvestmentNetReturnSeriesWithResponse request returning *GetInvestmentNetReturnSeriesResponse
func (c *ClientWithResponses) GetInvestmentNetReturnSeriesWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentNetReturnSeriesParams, reqEditors ...RequestEditorFn) (*GetInvestmentNetReturnSeriesResponse, error) {
	rsp, err := c.GetInvestmentNetReturnSeries(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentNetReturnSeriesResponse(rsp)
}

// GetInvestmentPendingTransactionsWithResponse request returning *GetInvestmentPendingTransactionsResponse
func (c *ClientWithResponses) GetInvestmentPendingTransactionsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentPendingTransactionsParams, reqEditors ...RequestEditorFn) (*GetInvestmentPendingTransactionsResponse, error) {
	rsp, err := c.GetInvestmentPendingTransactions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentPendingTransactionsResponse(rsp)
}

// GetInvestmentsFundsPriceDatesWithResponse request returning *GetInvestmentsFundsPriceDatesResponse
func (c *ClientWithResponses) GetInvestmentsFundsPriceDatesWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestmentsFundsPriceDatesResponse, error) {
	rsp, err := c.GetInvestmentsFundsPriceDates(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentsFundsPriceDatesResponse(rsp)
}

// GetInvestmentStandingInstructionsWithResponse request returning *GetInvestmentStandingInstructionsResponse
func (c *ClientWithResponses) GetInvestmentStandingInstructionsWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestmentStandingInstructionsResponse, error) {
	rsp, err := c.GetInvestmentStandingInstructions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentStandingInstructionsResponse(rsp)
}

// GetInvestmentTargetFundAllocationWithResponse request returning *GetInvestmentTargetFundAllocationResponse
func (c *ClientWithResponses) GetInvestmentTargetFundAllocationWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestmentTargetFundAllocationResponse, error) {
	rsp, err := c.GetInvestmentTargetFundAllocation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentTargetFundAllocationResponse(rsp)
}

// GetInvestmentTotalValueWithResponse request returning *GetInvestmentTotalValueResponse
func (c *ClientWithResponses) GetInvestmentTotalValueWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTotalValueParams, reqEditors ...RequestEditorFn) (*GetInvestmentTotalValueResponse, error) {
	rsp, err := c.GetInvestmentTotalValue(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentTotalValueResponse(rsp)
}

// GetInvestmentTotalValueSeriesWithResponse request returning *GetInvestmentTotalValueSeriesResponse
func (c *ClientWithResponses) GetInvestmentTotalValueSeriesWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTotalValueSeriesParams, reqEditors ...RequestEditorFn) (*GetInvestmentTotalValueSeriesResponse, error) {
	rsp, err := c.GetInvestmentTotalValueSeries(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentTotalValueSeriesResponse(rsp)
}

// GetPagedInvestmentTransactionsWithResponse request returning *GetPagedInvestmentTransactionsResponse
func (c *ClientWithResponses) GetPagedInvestmentTransactionsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetPagedInvestmentTransactionsParams, reqEditors ...RequestEditorFn) (*GetPagedInvestmentTransactionsResponse, error) {
	rsp, err := c.GetPagedInvestmentTransactions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPagedInvestmentTransactionsResponse(rsp)
}

// GetInvestmentTransactionBalanceBreakdownWithResponse request returning *GetInvestmentTransactionBalanceBreakdownResponse
func (c *ClientWithResponses) GetInvestmentTransactionBalanceBreakdownWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTransactionBalanceBreakdownParams, reqEditors ...RequestEditorFn) (*GetInvestmentTransactionBalanceBreakdownResponse, error) {
	rsp, err := c.GetInvestmentTransactionBalanceBreakdown(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentTransactionBalanceBreakdownResponse(rsp)
}

// GetInvestmentTransactionsCsvWithResponse request returning *GetInvestmentTransactionsCsvResponse
func (c *ClientWithResponses) GetInvestmentTransactionsCsvWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTransactionsCsvParams, reqEditors ...RequestEditorFn) (*GetInvestmentTransactionsCsvResponse, error) {
	rsp, err := c.GetInvestmentTransactionsCsv(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentTransactionsCsvResponse(rsp)
}

// GetInvestmentTransactionHighlightsWithResponse request returning *GetInvestmentTransactionHighlightsResponse
func (c *ClientWithResponses) GetInvestmentTransactionHighlightsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestmentTransactionHighlightsParams, reqEditors ...RequestEditorFn) (*GetInvestmentTransactionHighlightsResponse, error) {
	rsp, err := c.GetInvestmentTransactionHighlights(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestmentTransactionHighlightsResponse(rsp)
}

// GetPagedInvestorTotalValuesWithResponse request returning *GetPagedInvestorTotalValuesResponse
func (c *ClientWithResponses) GetPagedInvestorTotalValuesWithResponse(ctx context.Context, params *GetPagedInvestorTotalValuesParams, reqEditors ...RequestEditorFn) (*GetPagedInvestorTotalValuesResponse, error) {
	rsp, err := c.GetPagedInvestorTotalValues(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPagedInvestorTotalValuesResponse(rsp)
}

// GetInvestorFmcaTopAssetsWithResponse request returning *GetInvestorFmcaTopAssetsResponse
func (c *ClientWithResponses) GetInvestorFmcaTopAssetsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorFmcaTopAssetsParams, reqEditors ...RequestEditorFn) (*GetInvestorFmcaTopAssetsResponse, error) {
	rsp, err := c.GetInvestorFmcaTopAssets(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestorFmcaTopAssetsResponse(rsp)
}

// GetInvestorGainsWithResponse request returning *GetInvestorGainsResponse
func (c *ClientWithResponses) GetInvestorGainsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorGainsParams, reqEditors ...RequestEditorFn) (*GetInvestorGainsResponse, error) {
	rsp, err := c.GetInvestorGains(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestorGainsResponse(rsp)
}

// GetInvestorInceptionDateWithResponse request returning *GetInvestorInceptionDateResponse
func (c *ClientWithResponses) GetInvestorInceptionDateWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestorInceptionDateResponse, error) {
	rsp, err := c.GetInvestorInceptionDate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestorInceptionDateResponse(rsp)
}

// GetPagedInvestorInvestmentsWithResponse request returning *GetPagedInvestorInvestmentsResponse
func (c *ClientWithResponses) GetPagedInvestorInvestmentsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetPagedInvestorInvestmentsParams, reqEditors ...RequestEditorFn) (*GetPagedInvestorInvestmentsResponse, error) {
	rsp, err := c.GetPagedInvestorInvestments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPagedInvestorInvestmentsResponse(rsp)
}

// GetInvestorNetReturnWithResponse request returning *GetInvestorNetReturnResponse
func (c *ClientWithResponses) GetInvestorNetReturnWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorNetReturnParams, reqEditors ...RequestEditorFn) (*GetInvestorNetReturnResponse, error) {
	rsp, err := c.GetInvestorNetReturn(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestorNetReturnResponse(rsp)
}

// GetInvestorPendingTransactionsWithResponse request returning *GetInvestorPendingTransactionsResponse
func (c *ClientWithResponses) GetInvestorPendingTransactionsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorPendingTransactionsParams, reqEditors ...RequestEditorFn) (*GetInvestorPendingTransactionsResponse, error) {
	rsp, err := c.GetInvestorPendingTransactions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestorPendingTransactionsResponse(rsp)
}

// GetInvestorStandingInstructionsWithResponse request returning *GetInvestorStandingInstructionsResponse
func (c *ClientWithResponses) GetInvestorStandingInstructionsWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetInvestorStandingInstructionsResponse, error) {
	rsp, err := c.GetInvestorStandingInstructions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestorStandingInstructionsResponse(rsp)
}

// GetInvestorTotalValueWithResponse request returning *GetInvestorTotalValueResponse
func (c *ClientWithResponses) GetInvestorTotalValueWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorTotalValueParams, reqEditors ...RequestEditorFn) (*GetInvestorTotalValueResponse, error) {
	rsp, err := c.GetInvestorTotalValue(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestorTotalValueResponse(rsp)
}

// GetPagedInvestorTransactionsWithResponse request returning *GetPagedInvestorTransactionsResponse
func (c *ClientWithResponses) GetPagedInvestorTransactionsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetPagedInvestorTransactionsParams, reqEditors ...RequestEditorFn) (*GetPagedInvestorTransactionsResponse, error) {
	rsp, err := c.GetPagedInvestorTransactions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPagedInvestorTransactionsResponse(rsp)
}

// GetInvestorTransactionBalanceBreakdownWithResponse request returning *GetInvestorTransactionBalanceBreakdownResponse
func (c *ClientWithResponses) GetInvestorTransactionBalanceBreakdownWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorTransactionBalanceBreakdownParams, reqEditors ...RequestEditorFn) (*GetInvestorTransactionBalanceBreakdownResponse, error) {
	rsp, err := c.GetInvestorTransactionBalanceBreakdown(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestorTransactionBalanceBreakdownResponse(rsp)
}

// GetInvestorTransactionHighlightsWithResponse request returning *GetInvestorTransactionHighlightsResponse
func (c *ClientWithResponses) GetInvestorTransactionHighlightsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInvestorTransactionHighlightsParams, reqEditors ...RequestEditorFn) (*GetInvestorTransactionHighlightsResponse, error) {
	rsp, err := c.GetInvestorTransactionHighlights(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvestorTransactionHighlightsResponse(rsp)
}

// GetLatestPriceDateWithResponse request returning *GetLatestPriceDateResponse
func (c *ClientWithResponses) GetLatestPriceDateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLatestPriceDateResponse, error) {
	rsp, err := c.GetLatestPriceDate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestPriceDateResponse(rsp)
}

// GetNetReturnSeriesWithResponse request returning *GetNetReturnSeriesResponse
func (c *ClientWithResponses) GetNetReturnSeriesWithResponse(ctx context.Context, params *GetNetReturnSeriesParams, reqEditors ...RequestEditorFn) (*GetNetReturnSeriesResponse, error) {
	rsp, err := c.GetNetReturnSeries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetReturnSeriesResponse(rsp)
}

// GetPendingTransactionsWithResponse request returning *GetPendingTransactionsResponse
func (c *ClientWithResponses) GetPendingTransactionsWithResponse(ctx context.Context, params *GetPendingTransactionsParams, reqEditors ...RequestEditorFn) (*GetPendingTransactionsResponse, error) {
	rsp, err := c.GetPendingTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPendingTransactionsResponse(rsp)
}

// GetStandingInstructionsWithResponse request returning *GetStandingInstructionsResponse
func (c *ClientWithResponses) GetStandingInstructionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStandingInstructionsResponse, error) {
	rsp, err := c.GetStandingInstructions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStandingInstructionsResponse(rsp)
}

// GetTotalValueWithResponse request returning *GetTotalValueResponse
func (c *ClientWithResponses) GetTotalValueWithResponse(ctx context.Context, params *GetTotalValueParams, reqEditors ...RequestEditorFn) (*GetTotalValueResponse, error) {
	rsp, err := c.GetTotalValue(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTotalValueResponse(rsp)
}

// GetTotalValueSeriesWithResponse request returning *GetTotalValueSeriesResponse
func (c *ClientWithResponses) GetTotalValueSeriesWithResponse(ctx context.Context, params *GetTotalValueSeriesParams, reqEditors ...RequestEditorFn) (*GetTotalValueSeriesResponse, error) {
	rsp, err := c.GetTotalValueSeries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTotalValueSeriesResponse(rsp)
}

// GetPagedTransactionsWithResponse request returning *GetPagedTransactionsResponse
func (c *ClientWithResponses) GetPagedTransactionsWithResponse(ctx context.Context, params *GetPagedTransactionsParams, reqEditors ...RequestEditorFn) (*GetPagedTransactionsResponse, error) {
	rsp, err := c.GetPagedTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPagedTransactionsResponse(rsp)
}

// GetTransactionBalanceBreakdownWithResponse request returning *GetTransactionBalanceBreakdownResponse
func (c *ClientWithResponses) GetTransactionBalanceBreakdownWithResponse(ctx context.Context, params *GetTransactionBalanceBreakdownParams, reqEditors ...RequestEditorFn) (*GetTransactionBalanceBreakdownResponse, error) {
	rsp, err := c.GetTransactionBalanceBreakdown(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionBalanceBreakdownResponse(rsp)
}

// GetTransactionHighlightsWithResponse request returning *GetTransactionHighlightsResponse
func (c *ClientWithResponses) GetTransactionHighlightsWithResponse(ctx context.Context, params *GetTransactionHighlightsParams, reqEditors ...RequestEditorFn) (*GetTransactionHighlightsResponse, error) {
	rsp, err := c.GetTransactionHighlights(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionHighlightsResponse(rsp)
}

// ParseGetFmcaTopAssetsResponse parses an HTTP response from a GetFmcaTopAssetsWithResponse call
func ParseGetFmcaTopAssetsResponse(rsp *http.Response) (*GetFmcaTopAssetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFmcaTopAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FmcaTopAssetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetFundRiskResponse parses an HTTP response from a GetFundRiskWithResponse call
func ParseGetFundRiskResponse(rsp *http.Response) (*GetFundRiskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundRiskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FundRiskResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetFundUnitPriceSeriesResponse parses an HTTP response from a GetFundUnitPriceSeriesWithResponse call
func ParseGetFundUnitPriceSeriesResponse(rsp *http.Response) (*GetFundUnitPriceSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundUnitPriceSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UnitPriceSeriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetFundVolatilityResponse parses an HTTP response from a GetFundVolatilityWithResponse call
func ParseGetFundVolatilityResponse(rsp *http.Response) (*GetFundVolatilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundVolatilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FundVolatilityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetGainsResponse parses an HTTP response from a GetGainsWithResponse call
func ParseGetGainsResponse(rsp *http.Response) (*GetGainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GainsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInceptionDateResponse parses an HTTP response from a GetInceptionDateWithResponse call
func ParseGetInceptionDateResponse(rsp *http.Response) (*GetInceptionDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInceptionDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InceptionDateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetPagedInvestmentsResponse parses an HTTP response from a GetPagedInvestmentsWithResponse call
func ParseGetPagedInvestmentsResponse(rsp *http.Response) (*GetPagedInvestmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPagedInvestmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InvestmentsPagedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetPagedInvestmentTotalValuesResponse parses an HTTP response from a GetPagedInvestmentTotalValuesWithResponse call
func ParseGetPagedInvestmentTotalValuesResponse(rsp *http.Response) (*GetPagedInvestmentTotalValuesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPagedInvestmentTotalValuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InvestmentsTotalValuePagedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentResponse parses an HTTP response from a GetInvestmentWithResponse call
func ParseGetInvestmentResponse(rsp *http.Response) (*GetInvestmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Investment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentBankAccountsResponse parses an HTTP response from a GetInvestmentBankAccountsWithResponse call
func ParseGetInvestmentBankAccountsResponse(rsp *http.Response) (*GetInvestmentBankAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentBankAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InvestmentBankAccountsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetFmcaInvestmentMixResponse parses an HTTP response from a GetFmcaInvestmentMixWithResponse call
func ParseGetFmcaInvestmentMixResponse(rsp *http.Response) (*GetFmcaInvestmentMixResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFmcaInvestmentMixResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FmcaInvestmentMixResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentFmcaTopAssetsResponse parses an HTTP response from a GetInvestmentFmcaTopAssetsWithResponse call
func ParseGetInvestmentFmcaTopAssetsResponse(rsp *http.Response) (*GetInvestmentFmcaTopAssetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentFmcaTopAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FmcaTopAssetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentFundsResponse parses an HTTP response from a GetInvestmentFundsWithResponse call
func ParseGetInvestmentFundsResponse(rsp *http.Response) (*GetInvestmentFundsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentFundsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InvestmentHoldingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentGainsResponse parses an HTTP response from a GetInvestmentGainsWithResponse call
func ParseGetInvestmentGainsResponse(rsp *http.Response) (*GetInvestmentGainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentGainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GainsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentNetReturnResponse parses an HTTP response from a GetInvestmentNetReturnWithResponse call
func ParseGetInvestmentNetReturnResponse(rsp *http.Response) (*GetInvestmentNetReturnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentNetReturnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentNetReturnSeriesResponse parses an HTTP response from a GetInvestmentNetReturnSeriesWithResponse call
func ParseGetInvestmentNetReturnSeriesResponse(rsp *http.Response) (*GetInvestmentNetReturnSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentNetReturnSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetReturnSeriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentPendingTransactionsResponse parses an HTTP response from a GetInvestmentPendingTransactionsWithResponse call
func ParseGetInvestmentPendingTransactionsResponse(rsp *http.Response) (*GetInvestmentPendingTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentPendingTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PendingTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentsFundsPriceDatesResponse parses an HTTP response from a GetInvestmentsFundsPriceDatesWithResponse call
func ParseGetInvestmentsFundsPriceDatesResponse(rsp *http.Response) (*GetInvestmentsFundsPriceDatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentsFundsPriceDatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FundPriceDatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentStandingInstructionsResponse parses an HTTP response from a GetInvestmentStandingInstructionsWithResponse call
func ParseGetInvestmentStandingInstructionsResponse(rsp *http.Response) (*GetInvestmentStandingInstructionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentStandingInstructionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StandingInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentTargetFundAllocationResponse parses an HTTP response from a GetInvestmentTargetFundAllocationWithResponse call
func ParseGetInvestmentTargetFundAllocationResponse(rsp *http.Response) (*GetInvestmentTargetFundAllocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentTargetFundAllocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TargetFundAllocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentTotalValueResponse parses an HTTP response from a GetInvestmentTotalValueWithResponse call
func ParseGetInvestmentTotalValueResponse(rsp *http.Response) (*GetInvestmentTotalValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentTotalValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InvestmentTotalValueResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentTotalValueSeriesResponse parses an HTTP response from a GetInvestmentTotalValueSeriesWithResponse call
func ParseGetInvestmentTotalValueSeriesResponse(rsp *http.Response) (*GetInvestmentTotalValueSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentTotalValueSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TotalValueSeriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetPagedInvestmentTransactionsResponse parses an HTTP response from a GetPagedInvestmentTransactionsWithResponse call
func ParseGetPagedInvestmentTransactionsResponse(rsp *http.Response) (*GetPagedInvestmentTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPagedInvestmentTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionsPagedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentTransactionBalanceBreakdownResponse parses an HTTP response from a GetInvestmentTransactionBalanceBreakdownWithResponse call
func ParseGetInvestmentTransactionBalanceBreakdownResponse(rsp *http.Response) (*GetInvestmentTransactionBalanceBreakdownResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentTransactionBalanceBreakdownResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BalanceBreakdownResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentTransactionsCsvResponse parses an HTTP response from a GetInvestmentTransactionsCsvWithResponse call
func ParseGetInvestmentTransactionsCsvResponse(rsp *http.Response) (*GetInvestmentTransactionsCsvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentTransactionsCsvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SystemIOStream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestmentTransactionHighlightsResponse parses an HTTP response from a GetInvestmentTransactionHighlightsWithResponse call
func ParseGetInvestmentTransactionHighlightsResponse(rsp *http.Response) (*GetInvestmentTransactionHighlightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestmentTransactionHighlightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionHighlightsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetPagedInvestorTotalValuesResponse parses an HTTP response from a GetPagedInvestorTotalValuesWithResponse call
func ParseGetPagedInvestorTotalValuesResponse(rsp *http.Response) (*GetPagedInvestorTotalValuesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPagedInvestorTotalValuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InvestorsTotalValuePagedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestorFmcaTopAssetsResponse parses an HTTP response from a GetInvestorFmcaTopAssetsWithResponse call
func ParseGetInvestorFmcaTopAssetsResponse(rsp *http.Response) (*GetInvestorFmcaTopAssetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestorFmcaTopAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FmcaTopAssetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestorGainsResponse parses an HTTP response from a GetInvestorGainsWithResponse call
func ParseGetInvestorGainsResponse(rsp *http.Response) (*GetInvestorGainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestorGainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GainsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestorInceptionDateResponse parses an HTTP response from a GetInvestorInceptionDateWithResponse call
func ParseGetInvestorInceptionDateResponse(rsp *http.Response) (*GetInvestorInceptionDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestorInceptionDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InceptionDateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetPagedInvestorInvestmentsResponse parses an HTTP response from a GetPagedInvestorInvestmentsWithResponse call
func ParseGetPagedInvestorInvestmentsResponse(rsp *http.Response) (*GetPagedInvestorInvestmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPagedInvestorInvestmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InvestmentsPagedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestorNetReturnResponse parses an HTTP response from a GetInvestorNetReturnWithResponse call
func ParseGetInvestorNetReturnResponse(rsp *http.Response) (*GetInvestorNetReturnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestorNetReturnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestorPendingTransactionsResponse parses an HTTP response from a GetInvestorPendingTransactionsWithResponse call
func ParseGetInvestorPendingTransactionsResponse(rsp *http.Response) (*GetInvestorPendingTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestorPendingTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PendingTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestorStandingInstructionsResponse parses an HTTP response from a GetInvestorStandingInstructionsWithResponse call
func ParseGetInvestorStandingInstructionsResponse(rsp *http.Response) (*GetInvestorStandingInstructionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestorStandingInstructionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StandingInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestorTotalValueResponse parses an HTTP response from a GetInvestorTotalValueWithResponse call
func ParseGetInvestorTotalValueResponse(rsp *http.Response) (*GetInvestorTotalValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestorTotalValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InvestorTotalValueResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetPagedInvestorTransactionsResponse parses an HTTP response from a GetPagedInvestorTransactionsWithResponse call
func ParseGetPagedInvestorTransactionsResponse(rsp *http.Response) (*GetPagedInvestorTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPagedInvestorTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionsPagedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestorTransactionBalanceBreakdownResponse parses an HTTP response from a GetInvestorTransactionBalanceBreakdownWithResponse call
func ParseGetInvestorTransactionBalanceBreakdownResponse(rsp *http.Response) (*GetInvestorTransactionBalanceBreakdownResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestorTransactionBalanceBreakdownResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BalanceBreakdownResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetInvestorTransactionHighlightsResponse parses an HTTP response from a GetInvestorTransactionHighlightsWithResponse call
func ParseGetInvestorTransactionHighlightsResponse(rsp *http.Response) (*GetInvestorTransactionHighlightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvestorTransactionHighlightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionHighlightsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetLatestPriceDateResponse parses an HTTP response from a GetLatestPriceDateWithResponse call
func ParseGetLatestPriceDateResponse(rsp *http.Response) (*GetLatestPriceDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestPriceDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LatestPriceDateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetNetReturnSeriesResponse parses an HTTP response from a GetNetReturnSeriesWithResponse call
func ParseGetNetReturnSeriesResponse(rsp *http.Response) (*GetNetReturnSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetReturnSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetReturnSeriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetPendingTransactionsResponse parses an HTTP response from a GetPendingTransactionsWithResponse call
func ParseGetPendingTransactionsResponse(rsp *http.Response) (*GetPendingTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPendingTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PendingTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetStandingInstructionsResponse parses an HTTP response from a GetStandingInstructionsWithResponse call
func ParseGetStandingInstructionsResponse(rsp *http.Response) (*GetStandingInstructionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStandingInstructionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StandingInstructionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetTotalValueResponse parses an HTTP response from a GetTotalValueWithResponse call
func ParseGetTotalValueResponse(rsp *http.Response) (*GetTotalValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTotalValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TotalValueSeriesItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetTotalValueSeriesResponse parses an HTTP response from a GetTotalValueSeriesWithResponse call
func ParseGetTotalValueSeriesResponse(rsp *http.Response) (*GetTotalValueSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTotalValueSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TotalValueSeriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetPagedTransactionsResponse parses an HTTP response from a GetPagedTransactionsWithResponse call
func ParseGetPagedTransactionsResponse(rsp *http.Response) (*GetPagedTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPagedTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionsPagedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetTransactionBalanceBreakdownResponse parses an HTTP response from a GetTransactionBalanceBreakdownWithResponse call
func ParseGetTransactionBalanceBreakdownResponse(rsp *http.Response) (*GetTransactionBalanceBreakdownResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionBalanceBreakdownResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BalanceBreakdownResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetTransactionHighlightsResponse parses an HTTP response from a GetTransactionHighlightsWithResponse call
func ParseGetTransactionHighlightsResponse(rsp *http.Response) (*GetTransactionHighlightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionHighlightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionHighlightsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xdS3PbOLb+Kyjdu7i3Sn70dOouskuczoxrJumU4+5e3J4FRB5JGJOAGgBla1L571MA",
	"+BRfAEjRspurODZx8DovHHzn4NsiYPGOUaBSLN5+W4hgCzHWP77HEaYBvOeAH0L2SO9A7BgVoP6Gw5BI",
	"wiiOvnC2Ay4JiMXbNY4ELBe70q++LYiEuPrDf3NYL94u/uuq6Poq7feqrdNbCfHi+3JBkyjCqwgWbyVP",
	"YLmQhx0s3i4w5/iw+P49/wVb/QsCqVp0UnSbCo5ZQqX6ac14jOXi7SJkiRpN3i9N4hVw1W8IIuBkp0ir",
	"Fi0DF5ITulHfrxMa3rAQLD5umubHOMC3dA9CxkDlJ/LkuV3rOMAfsITqLLGEC0ni0kSLgbttcOs4/Xe4",
	"m6T79N8JAfImwkKMvXHLxQ54AFTiDViykYBAMv4rjhJ4j4Vdq7ZFumc7PTdxxrxRG+Mwvmgm5yj2isBn",
	"HNvtsA8HZU3u9V8sea66rrVPutdruSBaYhjXHbvxlzMbN+5OQsMvnASgOEpMYlyauxzAYO30HAXLRYXE",
	"+InESewmiDGhro3aZnxHxIOvAuHwRwI0ONgxOWeOs3RaR07EgyW7SzbGwv3KIixJROThNSyf25osF/t8",
	"9t4q46+YUF9NsVcarrnnlql2jeSWBqBdO7UGniMKB7JU4fI4dhxETEDn5vVufmDLJSFRP68SNbRPILcs",
	"tONdgLvaAC33a7kgYaVhkpCw0Tkpb6KDKsVCAr+JSLry/QobJA6xxPWPldWx9St2nMSYH25Ts31rN0ch",
	"sUzsvBBp53x0s+J7TB/eBUF2TnLxskyrz2YX/TZ+VfRu7a+pNpnS8+mSYxpsBxAg4ovZ2ZIXt2IsAkz1",
	"BibrNXnypP24BXrDAUsIf5GBr7hb7/g0Xlwzs3k5cAWpv7EoVJN11KS2atBFygNfTkooMUEcL+NaW4up",
	"dzPbgoE7ec8kjvR5xnf8OSlLHSvzHkf0L7IxiC94A+HEW2FzftzhTSowXTS/mK/6Jlls2nNMt4FlJlwA",
	"xkdk2Zv2CGW/JXJzLU7G9ow/Iz807sYk3PAPLEHIPJ7wTKeKzyDvQCbcN9xPs/behigfwVfgBIRHOAVo",
	"mLn0/Za5e7y9QiMk5tKyN4vZTsLpTSvsZXW/5Ezv4uivpXHw+11zWDNuG42QOKpsIaHyx7+07yChEjZt",
	"LPgFqHJF7jmmAgdqXie6NeplL9PYOi4M6zUEkuzhhIEf9bH16crRmbLbjGmkpIcJvATmq8Sa6C0Vkien",
	"5KyhnFQ6Sh/tXHsXAY6Ahph/LMcpHdrZ37G48KuzPx9hIe8Sx6gQhSf3RqLODtaL3dD23j+C08CY00hZ",
	"n0T4idlBSIgvb3++/Co5YFe5CjC9A6w3ggMOf6bR4ajvUoAmwPQrwIP1x/ckBpZI6+9/48SwVP/XEdCN",
	"3B5bwf97s1i2Nc6t4HKxY4JkYIVa8/rnimBpKjWzW2/xqCbi0qRpZ+8x34D8mNDwXRSxAJf55aR82tWx",
	"P6P2Uj3hPaKTHR/hwrc4V3k79qGtV3+Cs+nx8KfhuqY18+O0wo35G9lsI7LZesdrAyy2H0oXO8LWzjPa",
	"16bXIV4D+DblYFwBCC0G30tNYu+oPJHbkONHHInxuHOco0oQ8ATCWxqwGAadWDwbK84a0PQmAszTE6kH",
	"CVfInu9pC3zXVjVJIiwhLO33h9MBDU972Fsudvigg5bDtm3InYm/FEv8dAcr/0tqWezgDaMSnuwuk0vN",
	"rI8KpTYOd/CyrFKwsOSuUquvLOEBOLdKVtL2kFpqZn2w7bglG6Z3J7ypGTUm8QslJup8ercsyboabf2P",
	"Bj/J6jctmMfKf9cac830CpZ1ePliTIkzkYro0W/3wIX5+ofLa9U92wHFO7J4u/jx8vryh4XSrnKrJ3O1",
	"jgN8IdnuQkNZ9e82IOsdm6iwQBhFREjE1khuAZlG6HFLgi0KGBWSyESC/ttGowuERGKLOWQttukNsvo/",
	"jiJUGAaBcBCAEGQVAZJMf50I4JcLPQOOM8W2+CvICoBXT4jjGCRwsXj7/8djVzYYMZoOUzLEQXICe6iM",
	"aKHWfPF28UcC/LDILuYNBy/T7Af765Paxq3RjrM9CSFcIg7qw0CKYhHNskqWLekWohCtDvoDsYOArAmE",
	"SNnclnGmfyrG2Tuk+y2gFDGKjCDpTTH9m1VKOL1EH2CNk8j87ofry5b+IxIT2bxQ7af44yH9tgWKtIzk",
	"rEXkFmFEYYOVO4U0WA8phiI0iJIQQkSoXiWeCnh1wFqo28ackvicEs+5qbaIeSTl+z/VYcF0pIXlL9fX",
	"Bu5BZQa32+0iYs7rV/9KbWNB0BnkbvQDPMlxie0iTEagduwaL37+u9I4b65/qKuQXyhO5JZx8m8IzUc/",
	"1j/6yPiKhCFQPVSRxAb/pGRe77Jku2MRiTF/AJlyxppxrVdKuoRUdSbeKB1R1plqcot/qv6uNHr+6lvA",
	"Qvh+lcGAOxWiZj0iHkzPmYTWFVYKj+7TVeo7TapZWWU9ZQytFHnBzxp0pBj0j4RwCDNz064TTsrNx4Bw",
	"X0ZupePKw3VCrex7Xd/w9zhEd/BHAkKelsWPuEn/qH4fJJwDlSi1SBkjf9QJHw3sq1yqC30CuhDaHek3",
	"7lGEVCukW4m856oBQv+jlXJ+xNUDEv+bcqxSzSnTKOFjFAkWm2+0Mk+1dUFS/4VjuoHLNsE5cqsGyFBp",
	"diOJUM2GfZWYm03SYyh6RGYXLtHtGlEmS/6AWpBiGZCyUmplHkkUIY0iQGvOYv0ZYB4R5VUZktkOqX1p",
	"s3IFDmG4G/MTDcebGtAQYcPzkXEV7SeVATmcp3RKldd25PDUfL3kHBVgO72z04NNmqikDjHakD3QEmfZ",
	"KMRqnkmvVS8+t7DtRQbPQAtf7fWF2PmG/KUB1r6LmofNbyR3lpa/keNc7P8GE9pv5vUVWMktRrpZ7jr3",
	"H8m9DLlO0eoTjiPjqeMIenABjoIk0gTbDsBZUtvIVs5lDGnm2/ARaCWhxNx9GfriAKfUBdU0PE8V0ELE",
	"UfKPqZydwFeFrvm8itgelB4ohGwHnLCwJP5GrIz452lrF1nctdfI5U2qDB/gKCJ0Y6R9hQWEypOvOKBp",
	"3AxxCBgPEd5jooOcCAecCdExq0tURBPfXL9BZF1olpCB0C7kFu8BYXpoobFEjKcNCW9bPU2DglrDLQ7z",
	"SF+jeqrkbS5OKCPNCaKestJDzFFm2qidMsqjvnhT/+Izk+gjU7qsLjk5Cx4xby/jNYd/cuEpftMfBd/h",
	"DYR5LNwiiq2ORhiJZCU0AlJqCgieiFDMrD77/fffDQJa/YDSa4iDOSqtAO3YzlzwpqR2HPaEJaKZkAFI",
	"91FqEgR9V1W9Ueg02c1hZHOVoXQMlijGB9WvCSirCZQjtLLUnq3RD9fX15foHeIgkigNi+t4wxoegSN9",
	"DaOoHnsfOv6MiFEeGG0SzDGVAGYEWnPRMLuFCLHEaIsFWgFQxAEHWzWse4ZCNc2YUFDKBVMmt8CrKxxs",
	"IcjiM0crzfjRJpqYJDsOUKu/vS+aERoqVQKiZVcRpuER4XKTZp46aZy+cpuh5qY7zvY3Y7QNoWbrtKGR",
	"ECM9ASS3RCBGQS+4brlm/BHzUCzRgSUowBQJ7RITkS5hyictIsIq8lCs870ikDOvYo44kQmOogOCpyBK",
	"BNlDMUKzkcX3bStoshScYkI266XYs7pa6YDqy7XCwYP1ejVpgnEWzOxm73qluRrDFqysYTM9tiaRBA76",
	"EqB0mlFuc/uNT5EOF8Kz+cmtSZzebkAfPWdPoJXg2TnSxhR7mPkrfRC+0BLjbvPNbZQ6Sadafo2UHSlz",
	"Yt0VKPvVS4RFFv/U/kvG8RZWuUB/Wtnn3LdPY05HQ88EKjtdQmvYdaTb8NlnmH2G2WeYfYYhPsNE9rkt",
	"33y4pe6l7G+z20mfqfXOjWrJKllDOT5pAIjJ6agb+W8k/G4VCivsQtF8mXJuaViF0T4KfSvlb37KrUT+",
	"RUvIKa+qUbPhDbc+GijdfufTlz87jbwMl4sR+P/8QlYYCUI3FQ629lIVA1+tMH24SAthCSt2Vi0wypo0",
	"YDmKPnq4s1zH6fVwamN1qsHc203Vm6NbyJ4Zl2dsV+W6wbyvMcrFby9iU/XMEqds4LVBpP4VKKEh8Oig",
	"zmAZxKQNbFuzAhWgofKvi9THKsiZ7YEry5WDndUy6MOhqdncCmmu1KqeQtSWM1Z6crxEazn2AUjfHoIe",
	"aN82ipMjfj9+unlXDqrE5MmoFdqrUErA3mal8kyJD552uCfpYdYOcybFnEkxZ1KMmUkxUMdmbxE4aFYn",
	"j0xnbJqPlT9Wwp2XsMltB/Y+basH/2xathkhmlsR7X5WcOyjaNtpjl61MrKDj13tFL2PXA0kJ5VRw9v5",
	"PqvDRgkAXRZMZZHLiGi309VgzGibjHqhRIsBz3jRzhFMoIdmEOqrB6E2g8CrysURgnqkXijIC56XUe2N",
	"WlKQqbvcrVtSrJ+nbsnLnHrol9IIn1fJOA3kvDVNx5mueZbZZeX5h3vqVZM9NVIHIUet1ETpuTWTR7T5",
	"SFW0nVUKWe/VULZ5si6KKg/91uI+hbYStuqqLf91AhF9hwIWx/hCgOpblu5sdfqvEsiVhjqH6sClZ6p1",
	"p3JgIVVdokd3XaL7coZBmjNssEkFxVwJwh74ITVHS9ORXmiNv6k1hrL+zO8kTOsuuJMYANt4papsnPTW",
	"XnK+au3801ubOaHJ+0r9HJEYEMQeogOKGN0AT1lXuKi6nSlcfVGqjuUSn0mbo3JzxEGNXv2WdRwFdSRj",
	"jaNo4KmwoeS3DQAy1yk4CGAndYioWsBAr32OrpJV+id27e6LDPjxxndWHt8p1VJXFXhP1WRF0lE9ddM8",
	"U1xWo8R3eVsVwWzTQromibGt9srHBIZ7A04oJlT7AjF+SiNnuqcevSJ0uLd4svWl41xa3tAdkJXfRc0j",
	"K7+R3JnhWdp4KYcmrtM7Aodwa1ac/4KU6ulbVebJWqJySyvz28P7TRX+Xzr/d75a4CkFdjQdZaGH6KRX",
	"Ds0cNlTdS13J/kLJygXOa9k7a/4q4EqgEATZUH0STQ+cpiMkdhHR7Srwq1bZQC33lhoinx1pJSuSYwzU",
	"IJAJjlr6UtuMORGM9kheU5H/ly55ne8weEqeHU1HyeshOqnklZyYlIv1VR8uc4WDkSkltlkFsyr4dhqW",
	"QCzlvMuI0AcjC03CpLREcz6bCetUMjQTKjPYiUDvbu5vf/2pWveCRodLdFtJ+jTwlSSKEOPo38AZWuEI",
	"0yBPljo6TmIOOrFL99YLwS9SJp4lvHaOWXodoazyuF5kLKv7ic+hcIQumt6AhEai08KGjtQENuGJmmRX",
	"PAZdxMw+Vaesu1zi8UepuO0Xh1pHlSPyxqXPlZWtmjjjWPxYOmS80PeL1xetb/z4ejS99Fy9mXaC51fr",
	"riqrjRHvOIkk2UWpeDqqELfwdjUFcceEPIqwThLjPs7wnyPcc4S7/qjHOPVCLAi6qp8OipP6KEaYR41X",
	"l4ldpWeOixUH/BCyx/5AxoazZKfPTRJHJv/jeHQnglCWJvfeDPt9Pmp34FN22lqVaEyNebIdwwx38nbc",
	"gq2GpKSpTCzZKbuX1bspM646AZToXKK/k0fyFe+Bp2kjS3QHEpMo/+8n8pT+3OZ1Zh3qN5uGlcuosYrQ",
	"EYFMGlcHE2IJWNg1lveHjy3LOU0my7HcDtX8/fQcFX8HwfPzOwv2rbOHF/TV2XwEYm/hkd58/RWtSQTP",
	"6Y82u6I3Yj97o39ub7T2hLbvdVorHdcrtDqhacNinc4mIhQFYo/SLRugO7b567wePmflhV2TPpe+NLtE",
	"Ej8t0RpAGBRlWH4D11LXjKVgiheIPTzUYoGeGZrvNJCXlgTktsrPGrTrfNl6+Nm5i6j/+bmR6ln7UiWO",
	"GNWJYnxgjc6cTEMZr75rzpd3mVmKIDI+VwidK4TOFULnCqFzhdAT4gcYP019UBu6XjiCTsJnikF3Qh00",
	"1Qtl3Ob+UDkbZ1kZqqVeXLahc1WouSrUXBVqrgr1DFWhKtCurppQuW4d/YHCXkyqf2SK8bkEzVyCZi5B",
	"M+k7iM2yXdI4XvVocv0z3guJDarG8Z3ElFLr84VpNQQa7hihGSrg6M3EvO9TvpuoqPW8nWhGcfyG4guv",
	"FD6/03jydxp7xd0i76Uk3Kd6wbHhSPYS33NUEtrxruNEaS5zWHcO685h3Tmse+YPP80PM47+MGN+tepn",
	"3x1LSeLNhsNGORwlUG2v79GW2updb5LxudrkuQcV3FZ5Lif5ZyonWdFRzRXWcg116vpq7tHPMTDAjE9U",
	"da1p/ueIBnYY51yFba7CNsSF6q2/VlFPnUi6k5efctVOnSpnLko1F6XqK0rlGEDsl465bo5T3ZwyyvTP",
	"WjVnCpDZ2CVquil6Astec3maQkGcsrLE1N59FS8+15t4Ub58d9h4TSK1d9lVQvn6JGWPoJLBoagvEblM",
	"7xveffmi/lnq//z24bfiPx9/+kn907ZCfWnbc5WMl1Elw9VvepYKGQPRXXN1jLk6xiutjjFXpHh9FSms",
	"oG+Oqvr5M8onxfPOeeZznvmcZ/568sxHwgs3KE1zdrwoXiqxCgemJ87ipQiDJzNAGxLmnB3gKFL6LxFQ",
	"Qg3XXr7uQAbfNYGBNblTAoE7QcD/0JPPn/VYnFDejroaKmm95BxlrJ3emQF0U341zFlwbUk0zCPoRib8",
	"3kl0QeHUgbeapf2fUOx9OHF+43B+43B+4/AkhrtR8OuvHTYlbGfaYMDTh1MgcVrGPTQqP2NtJsbazLCY",
	"1wOLaRdLr3PAlHCZZu+nUUe0gGNm4MrLAa40c2k3Nw6BpzQdmFv87RY4ShMjduE/5geOzunBklsJ8ViP",
	"lVRpDXyoJCX2bEgRe8HoBIqM82yRk4Q6PmLU/3TR/MrQ/MrQ631lqPek6fDk0DPhwLAR/zFwXzPe60We",
	"J2eQ0yCQk/v5q0/Cejz2kwOjxplFs8MwA6ROeMKYsUwzlunPhmWy01VekbozxzWdRi3PKCb/YcyAoxlw",
	"5AE4Gu124fv3/wQAAP//VJNYN2IFAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
