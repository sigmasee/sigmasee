// Code generated by sigmaseectl, DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"

	"github.com/life4/genesis/slices"
	"github.com/sigmasee/sigmasee/shared/enterprise/messaging"
	"github.com/sigmasee/sigmasee/shared/enterprise/messaging/schemaregistry"
	"go.uber.org/zap"
	"google.golang.org/protobuf/proto"
)

type Message struct {
	Key     []byte
	Headers map[string][]byte
	Event   *{{.EventType}}
}

type Producer interface {
	Produce(ctx context.Context, messages []*Message) error
}

type producer struct {
	logger          *zap.SugaredLogger
	messageProducer messaging.MessageProducer
}

type internalMessage struct {
	message messaging.Message
	err     error
}

func NewProducer(
	logger *zap.SugaredLogger,
	messageProducer messaging.MessageProducer) Producer {
	return &producer{
		logger:          logger,
		messageProducer: messageProducer,
	}
}

func (c *producer) Produce(ctx context.Context, messages []*Message) error {
	convertedMessagesWithErrors := slices.Map(messages, func(message *Message) internalMessage {
		data, err := proto.Marshal(message.Event)
		if err != nil {
			c.logger.Errorf(
				"Failed to serialize {{.EventType}}) message to Protobuf byte array. Error: %v",
				err)

			return internalMessage{
				message: messaging.Message{},
				err:     err,
			}
		}

		return internalMessage{
			message: messaging.Message{
				Topic:   TopicName,
				Key:     message.Key,
				Headers: message.Headers,
				Payload: append(schemaregistry.ReservedHeaders, data...),
			},
			err: nil,
		}
	})

	if slices.Any(convertedMessagesWithErrors, func(message internalMessage) bool {
		return message.err != nil
	}) {
		return fmt.Errorf("failed to serialize messages")
	}

	convertedMessages := slices.Map(convertedMessagesWithErrors, func(message internalMessage) messaging.Message {
		return message.message
	})

	if err := c.messageProducer.Produce(ctx, convertedMessages); err != nil {
		return err
	}

	return nil
}
