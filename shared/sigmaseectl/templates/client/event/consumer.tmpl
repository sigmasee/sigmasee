// Code generated by sigmaseectl, DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"
	"time"

	"github.com/sigmasee/sigmasee/shared/enterprise/configuration"
	enterprisecontext "github.com/sigmasee/sigmasee/shared/enterprise/context"
	"github.com/sigmasee/sigmasee/shared/enterprise/messaging"
	"github.com/sigmasee/sigmasee/shared/enterprise/messaging/schemaregistry"
	"go.uber.org/zap"
	"google.golang.org/protobuf/proto"
)

const consumerGroupHeaderKey = "consumer-group"

type Consumer interface {
	StartAsync(ctx context.Context) error
}

type consumer struct {
	logger          *zap.SugaredLogger
	appConfig       configuration.AppConfig
	contextHelper   enterprisecontext.ContextHelper
	subscriber      Subscriber
	messageConsumer messaging.MessageConsumer
	messageProducer messaging.MessageProducer
}

func NewConsumer(
	logger *zap.SugaredLogger,
	appConfig configuration.AppConfig,
	contextHelper enterprisecontext.ContextHelper,
	subscriber Subscriber,
	messageConsumer messaging.MessageConsumer,
	messageProducer messaging.MessageProducer) Consumer {
	return &consumer{
		logger:          logger,
		appConfig:       appConfig,
		contextHelper:   contextHelper,
		subscriber:      subscriber,
		messageConsumer: messageConsumer,
		messageProducer: messageProducer,
	}
}

func (s *consumer) StartAsync(ctx context.Context) error {
	go s.startAsync(ctx, TopicName, false, 0)

	for i := RetryTopicNameCount - 1; i >= 0; i-- {
		go s.startAsync(ctx, fmt.Sprintf("%s.%d", RetryTopicNamePrefix, i), true, i)
	}

	return nil
}

func (s *consumer) startAsync(ctx context.Context, topicName string, retryTopic bool, retryTopicIndex int) {
	for {
		if err := s.messageConsumer.Consume(ctx, topicName, func(message messaging.Message) error {
			if retryTopic {
				if header, ok := message.Headers[consumerGroupHeaderKey]; ok {
					if string(header) != s.appConfig.GetSource() {
						return nil
					}
				}
			}

			if len(schemaregistry.ReservedHeaders) >= len(message.Payload) {
				return s.logAndMoveToDeadLetterTopic(
					ctx,
					message,
					"missing the schema metadata")
			}

			if message.Payload[0] != 0 {
				return s.logAndMoveToDeadLetterTopic(
					ctx,
					message,
					"message does not start with magic byte")
			}

			event := {{.EventType}}{}
			if err := proto.Unmarshal(message.Payload[len(schemaregistry.ReservedHeaders):], &event); err != nil {
				return s.logAndMoveToDeadLetterTopic(
					ctx,
					message,
					fmt.Sprintf("Failed to de-serialize {{.EventType}} message. Error: %v", err))
			}

			ctx = s.contextHelper.WithCorrelationId(ctx, event.Metadata.CorrelationId)

			return s.handle(ctx, topicName, retryTopic, retryTopicIndex, message, &event)
		}); err != nil {
			s.logger.Errorf("Failed to call Consume method. Error: %v", err)
		}

		err := ctx.Err()
		if err == context.Canceled {
			return
		}
	}
}

func (s *consumer) handle(ctx context.Context, topicName string, retryTopic bool, retryTopicIndex int, message messaging.Message, event *{{.EventType}}) (err error) {
	start := time.Now()
	defer func(start time.Time) {
		s.logger.Infof("Handle event from Topic: %s - Event Type: %d, Execution time: %s. Error: %v", topicName, event.Metadata.Type, time.Since(start), err)
	}(start)

	defer func() {
		if r := recover(); r != nil {
			err = s.logAndMoveToDeadLetterTopic(
				ctx,
				message,
				fmt.Sprintf("Recovered from panic state. Event message. Error: %v", r))
		}
	}()

	if err = s.subscriber.Handle(ctx, message.Topic, message.Key, message.Headers, event); err != nil {
		errorMessage := fmt.Sprintf("Failed to handle Event message. Error: %v", err)

		if retryTopic {
			if retryTopicIndex == (RetryTopicNameCount - 1) {
				err = s.logAndMoveToDeadLetterTopic(ctx, message, errorMessage)
			} else {
				err = s.logAndMoveToRetryTopic(ctx, message, errorMessage, retryTopicIndex+1)
			}
		} else {
			if RetryTopicNameCount == 0 {
				err = s.logAndMoveToDeadLetterTopic(ctx, message, errorMessage)
			} else {
				err = s.logAndMoveToRetryTopic(ctx, message, errorMessage, 0)
			}
		}
	}

	return
}

func (s *consumer) logAndMoveToDeadLetterTopic(ctx context.Context, message messaging.Message, errorMessage string) error {
	s.logger.Infof("Moving to dead letter topic: %s, Error message: %s", DeadLetterTopicName, errorMessage)

	message.Topic = DeadLetterTopicName
	message.Headers["error"] = []byte(errorMessage)
	message.Headers[consumerGroupHeaderKey] = []byte(s.appConfig.GetSource())

	if err := s.messageProducer.Produce(ctx, []messaging.Message{message}); err != nil {
		s.logger.Errorf("Failed to move message to dead letter topic: %s. Error: %v", DeadLetterTopicName, err)

		return err
	}

	return nil
}

func (s *consumer) logAndMoveToRetryTopic(ctx context.Context, message messaging.Message, errorMessage string, retryTopicIndex int) error {
	topicName := fmt.Sprintf("%s.%d", RetryTopicNamePrefix, retryTopicIndex)

	s.logger.Infof("Moving to topic: %s, Error message: %s", topicName, errorMessage)

	message.Topic = topicName
	message.Headers["error"] = []byte(errorMessage)
	message.Headers[consumerGroupHeaderKey] = []byte(s.appConfig.GetSource())

	if err := s.messageProducer.Produce(ctx, []messaging.Message{message}); err != nil {
		s.logger.Errorf("Failed to move message to retry topic: %s. Error: %v", topicName, err)

		return err
	}

	return nil
}
