// Package openapiv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package openapiv1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// AddressesResponse defines model for AddressesResponse.
type AddressesResponse struct {
	Items *[]InvestorAddress `json:"items"`
}

// BalanceBreakdownResponse defines model for BalanceBreakdownResponse.
type BalanceBreakdownResponse struct {
	Items *[]BalanceBreakdownResponseItem `json:"items"`
}

// BalanceBreakdownResponseItem defines model for BalanceBreakdownResponseItem.
type BalanceBreakdownResponseItem struct {
	Amount      *float64 `json:"amount,omitempty"`
	Description *string  `json:"description"`
	FundCode    *string  `json:"fundCode"`
}

// Document defines model for Document.
type Document struct {
	DocumentDate *time.Time          `json:"documentDate,omitempty"`
	DocumentId   *openapi_types.UUID `json:"documentId,omitempty"`
	FileName     *string             `json:"fileName"`
	InvestmentId *openapi_types.UUID `json:"investmentId"`
	InvestorId   *openapi_types.UUID `json:"investorId"`
	Location     *string             `json:"location"`
	Metadata     *interface{}        `json:"metadata"`
}

// DocumentsResponse defines model for DocumentsResponse.
type DocumentsResponse struct {
	Items *[]Document `json:"items"`
}

// EmailAddressesResponse defines model for EmailAddressesResponse.
type EmailAddressesResponse struct {
	Items *[]InvestorEmailAddress `json:"items"`
}

// FmcaInvestmentMixResponse defines model for FmcaInvestmentMixResponse.
type FmcaInvestmentMixResponse struct {
	FmcaDate *time.Time                       `json:"fmcaDate,omitempty"`
	Items    *[]FmcaInvestmentMixResponseItem `json:"items"`
}

// FmcaInvestmentMixResponseItem defines model for FmcaInvestmentMixResponseItem.
type FmcaInvestmentMixResponseItem struct {
	FmcaAssetClass  *string  `json:"fmcaAssetClass"`
	FundCode        *string  `json:"fundCode"`
	Percentage      *float64 `json:"percentage,omitempty"`
	SectorValueBase *float64 `json:"sectorValueBase,omitempty"`
}

// FmcaTopAssetsResponse defines model for FmcaTopAssetsResponse.
type FmcaTopAssetsResponse struct {
	FmcaDate *time.Time                   `json:"fmcaDate,omitempty"`
	Items    *[]FmcaTopAssetsResponseItem `json:"items"`
}

// FmcaTopAssetsResponseItem defines model for FmcaTopAssetsResponseItem.
type FmcaTopAssetsResponseItem struct {
	AssetName              *string   `json:"assetName"`
	FmcaAssetClass         *string   `json:"fmcaAssetClass"`
	FmcaAssetType          *string   `json:"fmcaAssetType"`
	Funds                  *[]string `json:"funds"`
	InvestorAssetValueBase *float64  `json:"investorAssetValueBase,omitempty"`
	Percentage             *float64  `json:"percentage,omitempty"`
}

// FundPriceDatesResponse defines model for FundPriceDatesResponse.
type FundPriceDatesResponse struct {
	Items *[]FundPriceDatesResponseItem `json:"items"`
}

// FundPriceDatesResponseItem defines model for FundPriceDatesResponseItem.
type FundPriceDatesResponseItem struct {
	FundCode    *string    `json:"fundCode"`
	MaximumDate *time.Time `json:"maximumDate,omitempty"`
	MinimumDate *time.Time `json:"minimumDate,omitempty"`
}

// FundRiskResponse defines model for FundRiskResponse.
type FundRiskResponse struct {
	Frequency *string    `json:"frequency"`
	FromDate  *time.Time `json:"fromDate,omitempty"`
	FundCode  *string    `json:"fundCode"`
	Risk      *float64   `json:"risk,omitempty"`
	ToDate    *time.Time `json:"toDate,omitempty"`
}

// FundVolatilityResponse defines model for FundVolatilityResponse.
type FundVolatilityResponse struct {
	Frequency  *string    `json:"frequency"`
	FromDate   *time.Time `json:"fromDate,omitempty"`
	FundCode   *string    `json:"fundCode"`
	ToDate     *time.Time `json:"toDate,omitempty"`
	Volatility *float64   `json:"volatility,omitempty"`
}

// GainsResponse defines model for GainsResponse.
type GainsResponse struct {
	Value *float64 `json:"value"`
}

// InceptionDateResponse defines model for InceptionDateResponse.
type InceptionDateResponse struct {
	Date *time.Time `json:"date,omitempty"`
}

// Investment defines model for Investment.
type Investment struct {
	CloseDate          *time.Time          `json:"closeDate"`
	Code               *string             `json:"code"`
	DistributionMethod *string             `json:"distributionMethod"`
	FeeRate            *float64            `json:"feeRate"`
	Id                 *openapi_types.UUID `json:"id,omitempty"`
	InceptionDate      *time.Time          `json:"inceptionDate,omitempty"`
	MasterClient       *string             `json:"masterClient"`
	Metadata           *interface{}        `json:"metadata"`
	Name               *string             `json:"name"`
	PrimaryInvestorId  *openapi_types.UUID `json:"primaryInvestorId,omitempty"`
	Status             *string             `json:"status"`
	Type               *string             `json:"type"`
}

// InvestmentBankAccount defines model for InvestmentBankAccount.
type InvestmentBankAccount struct {
	AccountNumber   *float64   `json:"accountNumber"`
	BankAccountName *string    `json:"bankAccountName"`
	BankCode        *float64   `json:"bankCode"`
	BranchCode      *float64   `json:"branchCode"`
	IsPrimary       *bool      `json:"isPrimary,omitempty"`
	Suffix          *float64   `json:"suffix"`
	WhenCreatedUtc  *time.Time `json:"whenCreatedUtc"`
}

// InvestmentBankAccountsResponse defines model for InvestmentBankAccountsResponse.
type InvestmentBankAccountsResponse struct {
	Items *[]InvestmentBankAccount `json:"items"`
}

// InvestmentHolding defines model for InvestmentHolding.
type InvestmentHolding struct {
	Code  *string  `json:"code"`
	Name  *string  `json:"name"`
	Price *float64 `json:"price"`
	Units *float64 `json:"units,omitempty"`
}

// InvestmentHoldingsResponse defines model for InvestmentHoldingsResponse.
type InvestmentHoldingsResponse struct {
	Items *[]InvestmentHolding `json:"items"`
}

// InvestmentInvestorsResponse defines model for InvestmentInvestorsResponse.
type InvestmentInvestorsResponse struct {
	Items *[]InvestorDetail `json:"items"`
}

// InvestmentTotalValueResponse defines model for InvestmentTotalValueResponse.
type InvestmentTotalValueResponse struct {
	InvestmentId *openapi_types.UUID `json:"investmentId,omitempty"`
	TotalValue   *float64            `json:"totalValue"`
}

// InvestmentsPagedResponse defines model for InvestmentsPagedResponse.
type InvestmentsPagedResponse struct {
	Items  *[]Investment `json:"items"`
	Paging *Paging       `json:"paging,omitempty"`
}

// InvestmentsTotalValuePagedResponse defines model for InvestmentsTotalValuePagedResponse.
type InvestmentsTotalValuePagedResponse struct {
	Items  *[]InvestmentTotalValueResponse `json:"items"`
	Paging *Paging                         `json:"paging,omitempty"`
}

// Investor defines model for Investor.
type Investor struct {
	FirstName    *string             `json:"firstName"`
	Id           *openapi_types.UUID `json:"id,omitempty"`
	InvestorCode *string             `json:"investorCode"`
	LastName     *string             `json:"lastName"`
	MasterClient *string             `json:"masterClient"`
	Status       *string             `json:"status"`
	Title        *string             `json:"title"`
	Type         *string             `json:"type"`
}

// InvestorAddress defines model for InvestorAddress.
type InvestorAddress struct {
	AddressLine1 *string `json:"addressLine1"`
	AddressLine2 *string `json:"addressLine2"`
	AddressLine3 *string `json:"addressLine3"`
	AddressLine4 *string `json:"addressLine4"`
	City         *string `json:"city"`
	Country      *string `json:"country"`
	IsPrimary    *bool   `json:"isPrimary,omitempty"`
	PostalCode   *string `json:"postalCode"`
	Region       *string `json:"region"`
	State        *string `json:"state"`
}

// InvestorDetail defines model for InvestorDetail.
type InvestorDetail struct {
	AmlEntityType *string             `json:"amlEntityType"`
	DateOfBirth   *time.Time          `json:"dateOfBirth"`
	FirstName     *string             `json:"firstName"`
	Gender        *string             `json:"gender"`
	Greeting      *string             `json:"greeting"`
	Id            *openapi_types.UUID `json:"id,omitempty"`
	InvestorCode  *string             `json:"investorCode"`
	IrdNumber     *string             `json:"irdNumber"`
	LastName      *string             `json:"lastName"`
	MasterClient  *string             `json:"masterClient"`
	Metadata      *interface{}        `json:"metadata"`
	MiddleName    *string             `json:"middleName"`
	Name          *string             `json:"name"`
	Status        *string             `json:"status"`
	Title         *string             `json:"title"`
	Type          *string             `json:"type"`
}

// InvestorEmailAddress defines model for InvestorEmailAddress.
type InvestorEmailAddress struct {
	EmailAddress *string             `json:"emailAddress"`
	IsPrimary    *bool               `json:"isPrimary,omitempty"`
	UserId       *openapi_types.UUID `json:"userId"`
}

// InvestorPhoneNumber defines model for InvestorPhoneNumber.
type InvestorPhoneNumber struct {
	Country     *string `json:"country"`
	IsPrimary   *bool   `json:"isPrimary,omitempty"`
	PhoneNumber *string `json:"phoneNumber"`
}

// InvestorTotalValueResponse defines model for InvestorTotalValueResponse.
type InvestorTotalValueResponse struct {
	InvestmentCount *float64            `json:"investmentCount"`
	InvestorId      *openapi_types.UUID `json:"investorId,omitempty"`
	TotalValue      *float64            `json:"totalValue"`
}

// InvestorsPagedResponse defines model for InvestorsPagedResponse.
type InvestorsPagedResponse struct {
	Items  *[]Investor `json:"items"`
	Paging *Paging     `json:"paging,omitempty"`
}

// InvestorsTotalValuePagedResponse defines model for InvestorsTotalValuePagedResponse.
type InvestorsTotalValuePagedResponse struct {
	Items  *[]InvestorTotalValueResponse `json:"items"`
	Paging *Paging                       `json:"paging,omitempty"`
}

// LatestPriceDateResponse defines model for LatestPriceDateResponse.
type LatestPriceDateResponse struct {
	Date *time.Time `json:"date,omitempty"`
}

// NetReturnResponse defines model for NetReturnResponse.
type NetReturnResponse struct {
	NetReturn *float64 `json:"netReturn,omitempty"`
}

// NetReturnSeriesItem defines model for NetReturnSeriesItem.
type NetReturnSeriesItem struct {
	EndDate   *string  `json:"endDate"`
	NetReturn *float64 `json:"netReturn"`
	StartDate *string  `json:"startDate"`
}

// NetReturnSeriesResponse defines model for NetReturnSeriesResponse.
type NetReturnSeriesResponse struct {
	Items *[]NetReturnSeriesItem `json:"items"`
}

// Paging defines model for Paging.
type Paging struct {
	After  *string `json:"after"`
	Before *string `json:"before"`
	Total  *int32  `json:"total,omitempty"`
}

// PendingTransactionResponseItem defines model for PendingTransactionResponseItem.
type PendingTransactionResponseItem struct {
	Amount        *float64            `json:"amount"`
	AmountType    *string             `json:"amountType"`
	EffectiveDate *time.Time          `json:"effectiveDate,omitempty"`
	FundCode      *string             `json:"fundCode"`
	FundName      *string             `json:"fundName"`
	InvestmentId  *openapi_types.UUID `json:"investmentId,omitempty"`
}

// PendingTransactionsResponse defines model for PendingTransactionsResponse.
type PendingTransactionsResponse struct {
	Items *[]PendingTransactionResponseItem `json:"items"`
}

// PhoneNumbersResponse defines model for PhoneNumbersResponse.
type PhoneNumbersResponse struct {
	Items *[]InvestorPhoneNumber `json:"items"`
}

// PrescribedInvestorRateResponse defines model for PrescribedInvestorRateResponse.
type PrescribedInvestorRateResponse struct {
	Rate *float64 `json:"rate,omitempty"`
}

// StandingInstructionResponseItem defines model for StandingInstructionResponseItem.
type StandingInstructionResponseItem struct {
	Amount                  *float64            `json:"amount,omitempty"`
	AmountType              *string             `json:"amountType"`
	BankAccountId           *float64            `json:"bankAccountId,omitempty"`
	CalendarFrequency       *float64            `json:"calendarFrequency,omitempty"`
	CalendarName            *string             `json:"calendarName"`
	FundCode                *string             `json:"fundCode"`
	InvestmentId            *openapi_types.UUID `json:"investmentId,omitempty"`
	LastRunDate             *time.Time          `json:"lastRunDate,omitempty"`
	NextRunDate             *time.Time          `json:"nextRunDate,omitempty"`
	StandingInstructionId   *float64            `json:"standingInstructionId,omitempty"`
	StandingInstructionType *string             `json:"standingInstructionType"`
}

// StandingInstructionsResponse defines model for StandingInstructionsResponse.
type StandingInstructionsResponse struct {
	Items *[]StandingInstructionResponseItem `json:"items"`
}

// SystemIOStream defines model for System.IO.Stream.
type SystemIOStream struct {
	CanRead      *bool  `json:"canRead,omitempty"`
	CanSeek      *bool  `json:"canSeek,omitempty"`
	CanTimeout   *bool  `json:"canTimeout,omitempty"`
	CanWrite     *bool  `json:"canWrite,omitempty"`
	Length       *int64 `json:"length,omitempty"`
	Position     *int64 `json:"position,omitempty"`
	ReadTimeout  *int32 `json:"readTimeout,omitempty"`
	WriteTimeout *int32 `json:"writeTimeout,omitempty"`
}

// TargetFundAllocationResponse defines model for TargetFundAllocationResponse.
type TargetFundAllocationResponse struct {
	Items *[]TargetFundAllocationResponseItem `json:"items"`
}

// TargetFundAllocationResponseItem defines model for TargetFundAllocationResponseItem.
type TargetFundAllocationResponseItem struct {
	FundCode   *string  `json:"fundCode"`
	FundName   *string  `json:"fundName"`
	Percentage *float64 `json:"percentage,omitempty"`
}

// TotalValueSeriesItem defines model for TotalValueSeriesItem.
type TotalValueSeriesItem struct {
	Date       *string  `json:"date"`
	TotalValue *float64 `json:"totalValue"`
}

// TotalValueSeriesResponse defines model for TotalValueSeriesResponse.
type TotalValueSeriesResponse struct {
	Items *[]TotalValueSeriesItem `json:"items"`
}

// TransactionHighlightsResponse defines model for TransactionHighlightsResponse.
type TransactionHighlightsResponse struct {
	CashDistributions       *float64 `json:"cashDistributions,omitempty"`
	Contributions           *float64 `json:"contributions"`
	Fees                    *float64 `json:"fees"`
	ReinvestedDistributions *float64 `json:"reinvestedDistributions"`
	Tax                     *float64 `json:"tax"`
	Withdrawals             *float64 `json:"withdrawals"`
}

// TransactionResponseItem defines model for TransactionResponseItem.
type TransactionResponseItem struct {
	AccruedIncome                    *float64            `json:"accruedIncome"`
	Amount                           *float64            `json:"amount"`
	Cash                             *float64            `json:"cash"`
	CashClearing                     *float64            `json:"cashClearing"`
	Description                      *string             `json:"description"`
	EffectiveDate                    *time.Time          `json:"effectiveDate,omitempty"`
	Fee                              *float64            `json:"fee"`
	FormulatedTransactionDescription *string             `json:"formulatedTransactionDescription"`
	FundCode                         *string             `json:"fundCode"`
	FundName                         *string             `json:"fundName"`
	InvestmentId                     *openapi_types.UUID `json:"investmentId,omitempty"`
	PaymentClearing                  *float64            `json:"paymentClearing"`
	Price                            *float64            `json:"price"`
	Tax                              *float64            `json:"tax"`
	TaxRebate                        *float64            `json:"taxRebate"`
	TransactionContext               *string             `json:"transactionContext"`
	TransactionId                    *float64            `json:"transactionId,omitempty"`
	TransactionMethod                *string             `json:"transactionMethod"`
	TransactionReason                *string             `json:"transactionReason"`
	TransactionSource                *string             `json:"transactionSource"`
	TransactionSubtype               *string             `json:"transactionSubtype"`
	TransactionType                  *string             `json:"transactionType"`
	Units                            *float64            `json:"units"`
}

// TransactionsPagedResponse defines model for TransactionsPagedResponse.
type TransactionsPagedResponse struct {
	Items *[]TransactionResponseItem `json:"items"`
}

// UnitPriceSeriesItem defines model for UnitPriceSeriesItem.
type UnitPriceSeriesItem struct {
	Date      *string  `json:"date"`
	UnitPrice *float64 `json:"unitPrice"`
}

// UnitPriceSeriesResponse defines model for UnitPriceSeriesResponse.
type UnitPriceSeriesResponse struct {
	Items *[]UnitPriceSeriesItem `json:"items"`
}

// GetFmcaTopAssetsParams defines parameters for GetFmcaTopAssets.
type GetFmcaTopAssetsParams struct {
	// Date Date on which to retrieve the holdings
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Fund If provided, restricts the asset list to assets held by the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`

	// Limit The maximum number of assets to return. Defaults to 10.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// IncludeNegativeAssets When true, assets with a negative value are included in the response. Defaults to false.
	IncludeNegativeAssets *bool `form:"includeNegativeAssets,omitempty" json:"includeNegativeAssets,omitempty"`
}

// GetFundUnitPriceSeriesParams defines parameters for GetFundUnitPriceSeries.
type GetFundUnitPriceSeriesParams struct {
	// StartDate Start date for unit price series. If not provided, the date range queried will start from the earliest price for the fund.
	StartDate *time.Time `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate End date for unit price series. If not provided, the date range queried will end at the latest price for the fund.
	EndDate *time.Time `form:"endDate,omitempty" json:"endDate,omitempty"`
}

// GetGainsParams defines parameters for GetGains.
type GetGainsParams struct {
	// FromDate Start date for the gains calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the gains calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the gains calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetPagedInvestmentsParams defines parameters for GetPagedInvestments.
type GetPagedInvestmentsParams struct {
	// Limit The maximum number of objects that may be returned. Defaults to the maximum of 1000. A result list with fewer items than the specified limit is not a guarantee that the end of the data has been reached. To determine if another page exists, check for a \"before\" or \"after\" value on the response. \"Before\" indicates a previous page exists and \"after\" indicates a subsequent page exists.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// After If provided, the page returned will begin with the item after this one. To page forwards, you can set this value to the \"after\" property of a previous response. This parameter is mutually exclusive with the before parameter.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before If provided, the page returned will end with the item before this one. To page backwards, you can set this value to the \"before\" property of a previous response. This parameter is mutually exclusive with the after parameter.
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// InvestmentCode If provided, the investments will be filtered by investment code.
	InvestmentCode *string `form:"investmentCode,omitempty" json:"investmentCode,omitempty"`
}

// GetInvestmentsDocumentsParams defines parameters for GetInvestmentsDocuments.
type GetInvestmentsDocumentsParams struct {
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`
	ToDate   *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetPagedInvestmentTotalValuesParams defines parameters for GetPagedInvestmentTotalValues.
type GetPagedInvestmentTotalValuesParams struct {
	// Date The date for which the total value will be calculated.
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Limit The maximum number of objects that may be returned. Defaults to the maximum of 1000. A result list with fewer items than the specified limit is not a guarantee that the end of the data has been reached. To determine if another page exists, check for a \"before\" or \"after\" value on the response. \"Before\" indicates a previous page exists and \"after\" indicates a subsequent page exists.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// After If provided, the page returned will begin with the item after this one. To page forwards, you can set this value to the \"after\" property of a previous response. This parameter is mutually exclusive with the before parameter.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before If provided, the page returned will end with the item before this one. To page backwards, you can set this value to the \"before\" property of a previous response. This parameter is mutually exclusive with the after parameter.
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// GetInvestmentDocumentsParams defines parameters for GetInvestmentDocuments.
type GetInvestmentDocumentsParams struct {
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`
	ToDate   *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetFmcaInvestmentMixParams defines parameters for GetFmcaInvestmentMix.
type GetFmcaInvestmentMixParams struct {
	// Date Date on which to retrieve the holdings
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Fund If provided, restricts the asset list to assets held by the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetInvestmentFmcaTopAssetsParams defines parameters for GetInvestmentFmcaTopAssets.
type GetInvestmentFmcaTopAssetsParams struct {
	// Date Date on which to retrieve the holdings
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Fund If provided, restricts the asset list to assets held by the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`

	// Limit The maximum number of assets to return. Defaults to 10.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// IncludeNegativeAssets When true, assets with a negative value are included in the response. Defaults to false.
	IncludeNegativeAssets *bool `form:"includeNegativeAssets,omitempty" json:"includeNegativeAssets,omitempty"`
}

// GetInvestmentFundsParams defines parameters for GetInvestmentFunds.
type GetInvestmentFundsParams struct {
	// Date Date for which to retrieve holdings and prices
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`
}

// GetInvestmentGainsParams defines parameters for GetInvestmentGains.
type GetInvestmentGainsParams struct {
	// FromDate Start date for the gains calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the gains calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the gains calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetInvestmentNetReturnParams defines parameters for GetInvestmentNetReturn.
type GetInvestmentNetReturnParams struct {
	// FromDate Start date for the net return calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the net return calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund If provided, restricts the net return calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetInvestmentNetReturnSeriesParams defines parameters for GetInvestmentNetReturnSeries.
type GetInvestmentNetReturnSeriesParams struct {
	// Dates A comma-separated list of dates to be used as the start and end dates for the net return calculation. The earliest date will be the start date for every period, and each other date will be the end date for a single period.
	Dates *string `form:"dates,omitempty" json:"dates,omitempty"`

	// Fund If provided, restricts the net return calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetInvestmentPendingTransactionsParams defines parameters for GetInvestmentPendingTransactions.
type GetInvestmentPendingTransactionsParams struct {
	// FromDate The earliest acceptable effective date for returned transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetInvestmentPrescribedInvestorRateParams defines parameters for GetInvestmentPrescribedInvestorRate.
type GetInvestmentPrescribedInvestorRateParams struct {
	// Date The date for which the prescribed investor rate will be retrieved.
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`
}

// GetInvestmentTotalValueParams defines parameters for GetInvestmentTotalValue.
type GetInvestmentTotalValueParams struct {
	// Date The date for which the total value will be calculated.
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Fund If provided, restricts the total value calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetInvestmentTotalValueSeriesParams defines parameters for GetInvestmentTotalValueSeries.
type GetInvestmentTotalValueSeriesParams struct {
	// Dates A comma-separated list of dates for which the total value will be calculated.
	Dates *string `form:"dates,omitempty" json:"dates,omitempty"`

	// Fund If provided, restricts the total value calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetPagedInvestmentTransactionsParams defines parameters for GetPagedInvestmentTransactions.
type GetPagedInvestmentTransactionsParams struct {
	// FromDate The earliest acceptable effective date for returned transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetInvestmentTransactionBalanceBreakdownParams defines parameters for GetInvestmentTransactionBalanceBreakdown.
type GetInvestmentTransactionBalanceBreakdownParams struct {
	// FromDate Start date for the balance breakdown
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the balance breakdown
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund If provided, restricts the net return calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`

	// GroupingType If provided, changes the grouping of the transactions and description. KiwiSaverDefault, RetailDefault, MixDefault.
	GroupingType *string `form:"groupingType,omitempty" json:"groupingType,omitempty"`

	// GroupByFund If provided, the balance breakdowns are grouped by fund cod
	GroupByFund *bool `form:"groupByFund,omitempty" json:"groupByFund,omitempty"`
}

// GetInvestmentTransactionsCsvParams defines parameters for GetInvestmentTransactionsCsv.
type GetInvestmentTransactionsCsvParams struct {
	// FromDate The earliest acceptable effective date for returned transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetInvestmentTransactionHighlightsParams defines parameters for GetInvestmentTransactionHighlights.
type GetInvestmentTransactionHighlightsParams struct {
	// FromDate Start date for the highlights calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the highlights calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the highlights calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetPagedInvestorsParams defines parameters for GetPagedInvestors.
type GetPagedInvestorsParams struct {
	// Limit The maximum number of objects that may be returned. Defaults to the maximum of 1000. A result list with fewer items than the specified limit is not a guarantee that the end of the data has been reached. To determine if another page exists, check for a \"before\" or \"after\" value on the response. \"Before\" indicates a previous page exists and \"after\" indicates a subsequent page exists.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// After If provided, the page returned will begin with the item after this one. To page forwards, you can set this value to the \"after\" property of a previous response. This parameter is mutually exclusive with the before parameter.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before If provided, the page returned will end with the item before this one. To page backwards, you can set this value to the \"before\" property of a previous response. This parameter is mutually exclusive with the after parameter.
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// Search If provided, the results will be filtered to investors where the first or last names contain the search term
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// InvestorCode If provided, the results will be filtered to investors where the invester code contain the search term
	InvestorCode *string `form:"InvestorCode,omitempty" json:"InvestorCode,omitempty"`
}

// GetInvestorsDocumentsParams defines parameters for GetInvestorsDocuments.
type GetInvestorsDocumentsParams struct {
	IncludeInvestmentDocuments *bool      `form:"includeInvestmentDocuments,omitempty" json:"includeInvestmentDocuments,omitempty"`
	FromDate                   *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`
	ToDate                     *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetPagedInvestorTotalValuesParams defines parameters for GetPagedInvestorTotalValues.
type GetPagedInvestorTotalValuesParams struct {
	// Date The date for which the total value will be calculated.
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Limit The maximum number of objects that may be returned. Defaults to the maximum of 1000. A result list with fewer items than the specified limit is not a guarantee that the end of the data has been reached. To determine if another page exists, check for a \"before\" or \"after\" value on the response. \"Before\" indicates a previous page exists and \"after\" indicates a subsequent page exists.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// After If provided, the page returned will begin with the item after this one. To page forwards, you can set this value to the \"after\" property of a previous response. This parameter is mutually exclusive with the before parameter.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before If provided, the page returned will end with the item before this one. To page backwards, you can set this value to the \"before\" property of a previous response. This parameter is mutually exclusive with the after parameter.
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// GetInvestorDocumentsParams defines parameters for GetInvestorDocuments.
type GetInvestorDocumentsParams struct {
	IncludeInvestmentDocuments *bool      `form:"includeInvestmentDocuments,omitempty" json:"includeInvestmentDocuments,omitempty"`
	FromDate                   *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`
	ToDate                     *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetInvestorFmcaTopAssetsParams defines parameters for GetInvestorFmcaTopAssets.
type GetInvestorFmcaTopAssetsParams struct {
	// Date Date on which to retrieve the holdings
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Fund If provided, restricts the asset list to assets held by the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`

	// Limit The maximum number of assets to return. Defaults to 10.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// IncludeNegativeAssets When true, assets with a negative value are included in the response. Defaults to false.
	IncludeNegativeAssets *bool `form:"includeNegativeAssets,omitempty" json:"includeNegativeAssets,omitempty"`
}

// GetInvestorGainsParams defines parameters for GetInvestorGains.
type GetInvestorGainsParams struct {
	// FromDate Start date for the gains calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the gains calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the gains calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetPagedInvestorInvestmentsParams defines parameters for GetPagedInvestorInvestments.
type GetPagedInvestorInvestmentsParams struct {
	// Limit The maximum number of objects that may be returned. Defaults to the maximum of 1000. A result list with fewer items than the specified limit is not a guarantee that the end of the data has been reached. To determine if another page exists, check for a \"before\" or \"after\" value on the response. \"Before\" indicates a previous page exists and \"after\" indicates a subsequent page exists.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// After If provided, the page returned will begin with the item after this one. To page forwards, you can set this value to the \"after\" property of a previous response. This parameter is mutually exclusive with the before parameter.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before If provided, the page returned will end with the item before this one. To page backwards, you can set this value to the \"before\" property of a previous response. This parameter is mutually exclusive with the after parameter.
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// GetInvestorNetReturnParams defines parameters for GetInvestorNetReturn.
type GetInvestorNetReturnParams struct {
	// FromDate Start date for the net return calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the net return calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the net return calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetInvestorPendingTransactionsParams defines parameters for GetInvestorPendingTransactions.
type GetInvestorPendingTransactionsParams struct {
	// FromDate The earliest acceptable effective date for returned pending transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned pending transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetInvestorPrescribedInvestorRateParams defines parameters for GetInvestorPrescribedInvestorRate.
type GetInvestorPrescribedInvestorRateParams struct {
	// Date The date for which the prescribed investor rate will be retrieved.
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`
}

// GetInvestorTotalValueParams defines parameters for GetInvestorTotalValue.
type GetInvestorTotalValueParams struct {
	// Date The date for which the total value will be calculated.
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`
}

// GetPagedInvestorTransactionsParams defines parameters for GetPagedInvestorTransactions.
type GetPagedInvestorTransactionsParams struct {
	// FromDate The earliest acceptable effective date for returned transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Type If provided, filters the results to the specific transaction type, i.e. \"APP\", \"WDW\", \"FEE\"
	Type *string `form:"type,omitempty" json:"type,omitempty"`
}

// GetInvestorTransactionBalanceBreakdownParams defines parameters for GetInvestorTransactionBalanceBreakdown.
type GetInvestorTransactionBalanceBreakdownParams struct {
	// FromDate Start date for the balance breakdown
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the balance breakdown
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund If provided, restricts the net return calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`

	// GroupingType If provided, changes the grouping of the transactions and description. KiwiSaverDefault, RetailDefault, MixDefault.
	GroupingType *string `form:"groupingType,omitempty" json:"groupingType,omitempty"`
}

// GetInvestorTransactionHighlightsParams defines parameters for GetInvestorTransactionHighlights.
type GetInvestorTransactionHighlightsParams struct {
	// FromDate Start date for the highlights calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the highlights calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the highlights calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetNetReturnSeriesParams defines parameters for GetNetReturnSeries.
type GetNetReturnSeriesParams struct {
	// Dates A comma-separated list of dates to be used as the start and end dates for the net return calculation. The earliest date will be the start date for every period, and each other date will be the end date for a single period.
	Dates *string `form:"dates,omitempty" json:"dates,omitempty"`

	// Fund If provided, restricts the net return calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetPendingTransactionsParams defines parameters for GetPendingTransactions.
type GetPendingTransactionsParams struct {
	// FromDate The earliest acceptable effective date for returned pending transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned pending transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetTotalValueParams defines parameters for GetTotalValue.
type GetTotalValueParams struct {
	// Date The date for which the total value will be calculated.
	Date *time.Time `form:"date,omitempty" json:"date,omitempty"`

	// Fund If provided, restricts the total value calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetTotalValueSeriesParams defines parameters for GetTotalValueSeries.
type GetTotalValueSeriesParams struct {
	// Dates A comma-separated list of dates for which the total value will be calculated.
	Dates *string `form:"dates,omitempty" json:"dates,omitempty"`

	// Fund If provided, restricts the total value calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// GetPagedTransactionsParams defines parameters for GetPagedTransactions.
type GetPagedTransactionsParams struct {
	// FromDate The earliest acceptable effective date for returned transactions
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate The latest acceptable effective date for returned transactions
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`
}

// GetTransactionBalanceBreakdownParams defines parameters for GetTransactionBalanceBreakdown.
type GetTransactionBalanceBreakdownParams struct {
	// FromDate Start date for the balance breakdown
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the balance breakdown
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund If provided, restricts the net return calculation to the specified fund
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`

	// GroupingType If provided, changes the grouping of the transactions and description. KiwiSaverDefault, RetailDefault, MixDefault.
	GroupingType *string `form:"groupingType,omitempty" json:"groupingType,omitempty"`
}

// GetTransactionHighlightsParams defines parameters for GetTransactionHighlights.
type GetTransactionHighlightsParams struct {
	// FromDate Start date for the highlights calculation
	FromDate *time.Time `form:"fromDate,omitempty" json:"fromDate,omitempty"`

	// ToDate End date for the highlights calculation
	ToDate *time.Time `form:"toDate,omitempty" json:"toDate,omitempty"`

	// Fund Fund code for the highlights calculation
	Fund *string `form:"fund,omitempty" json:"fund,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get the top assets held by market value for all accessible investments
	// (GET /fmca-top-assets)
	GetFmcaTopAssets(w http.ResponseWriter, r *http.Request, params GetFmcaTopAssetsParams)
	// Get the risk for a fund for the current date
	// (GET /funds/{code}/risk)
	GetFundRisk(w http.ResponseWriter, r *http.Request, code string)
	// Get all unit prices for a fund for a given date range
	// (GET /funds/{code}/unit-price-series)
	GetFundUnitPriceSeries(w http.ResponseWriter, r *http.Request, code string, params GetFundUnitPriceSeriesParams)
	// Get the volatility for a fund for the current date
	// (GET /funds/{code}/volatility)
	GetFundVolatility(w http.ResponseWriter, r *http.Request, code string)
	// Get gains for all accessible investments over a specified period
	// (GET /gains)
	GetGains(w http.ResponseWriter, r *http.Request, params GetGainsParams)
	// Get earliest inception date across all accessible investments
	// (GET /inception-date)
	GetInceptionDate(w http.ResponseWriter, r *http.Request)
	// Get paged investments
	// (GET /investments)
	GetPagedInvestments(w http.ResponseWriter, r *http.Request, params GetPagedInvestmentsParams)

	// (GET /investments/documents)
	GetInvestmentsDocuments(w http.ResponseWriter, r *http.Request, params GetInvestmentsDocumentsParams)
	// Get paged list of total value for all accessible investments
	// (GET /investments/total-values)
	GetPagedInvestmentTotalValues(w http.ResponseWriter, r *http.Request, params GetPagedInvestmentTotalValuesParams)
	// Get a single investment
	// (GET /investments/{id})
	GetInvestment(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Get the bank accounts for a single investment
	// (GET /investments/{id}/bank-accounts)
	GetInvestmentBankAccounts(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)

	// (GET /investments/{id}/documents)
	GetInvestmentDocuments(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentDocumentsParams)

	// (GET /investments/{id}/documents/{documentId}/{fileName})
	GetInvestmentDocument(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, documentId openapi_types.UUID, fileName string)
	// Get the FMCA investment mix for an investment
	// (GET /investments/{id}/fmca-investment-mix)
	GetFmcaInvestmentMix(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetFmcaInvestmentMixParams)
	// Get the top assets held by market value for an investment
	// (GET /investments/{id}/fmca-top-assets)
	GetInvestmentFmcaTopAssets(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentFmcaTopAssetsParams)
	// Get units and price per fund for an investment on a given date
	// (GET /investments/{id}/funds)
	GetInvestmentFunds(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentFundsParams)
	// Get investment gains for an investment over a specified period
	// (GET /investments/{id}/gains)
	GetInvestmentGains(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentGainsParams)
	// Get investors linked an investment
	// (GET /investments/{id}/investors)
	GetInvestmentInvestors(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Get net return for an investment
	// (GET /investments/{id}/net-return)
	GetInvestmentNetReturn(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentNetReturnParams)
	// Get net return calculations for an investment across successively longer periods
	// (GET /investments/{id}/net-return-series)
	GetInvestmentNetReturnSeries(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentNetReturnSeriesParams)
	// Get paged pending transactions for an investment
	// (GET /investments/{id}/pending-transactions)
	GetInvestmentPendingTransactions(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentPendingTransactionsParams)
	// Get prescribed investor rate for an investment on a given date
	// (GET /investments/{id}/prescribed-investor-rate)
	GetInvestmentPrescribedInvestorRate(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentPrescribedInvestorRateParams)
	// Get  min and max price dates for all funds
	// (GET /investments/{id}/price-dates)
	GetInvestmentsFundsPriceDates(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Get standing instructions for an investment
	// (GET /investments/{id}/standing-instructions)
	GetInvestmentStandingInstructions(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Get investment target fund allocation
	// (GET /investments/{id}/target-fund-allocation)
	GetInvestmentTargetFundAllocation(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Get total value and active investment count for an investor
	// (GET /investments/{id}/total-value)
	GetInvestmentTotalValue(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentTotalValueParams)
	// Get total value of an investment across multiple dates
	// (GET /investments/{id}/total-value-series)
	GetInvestmentTotalValueSeries(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentTotalValueSeriesParams)
	// Get paged transactions for an investment
	// (GET /investments/{id}/transactions)
	GetPagedInvestmentTransactions(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetPagedInvestmentTransactionsParams)
	// Get transaction balance breakdown for an investment over a specified period
	// (GET /investments/{id}/transactions/balance-breakdown)
	GetInvestmentTransactionBalanceBreakdown(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentTransactionBalanceBreakdownParams)
	// Get transactions for an investment in csv format
	// (GET /investments/{id}/transactions/csv)
	GetInvestmentTransactionsCsv(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentTransactionsCsvParams)
	// Get transaction highlights for an investment over a specified period
	// (GET /investments/{id}/transactions/highlights)
	GetInvestmentTransactionHighlights(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentTransactionHighlightsParams)
	// Get paged investors
	// (GET /investors)
	GetPagedInvestors(w http.ResponseWriter, r *http.Request, params GetPagedInvestorsParams)

	// (GET /investors/documents)
	GetInvestorsDocuments(w http.ResponseWriter, r *http.Request, params GetInvestorsDocumentsParams)
	// Get paged total value and active investment count for all accessible investors
	// (GET /investors/total-values)
	GetPagedInvestorTotalValues(w http.ResponseWriter, r *http.Request, params GetPagedInvestorTotalValuesParams)
	// Get a single investor
	// (GET /investors/{id})
	GetInvestor(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Get addresses linked an investor
	// (GET /investors/{id}/addresses)
	GetInvestorAddresses(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)

	// (GET /investors/{id}/documents)
	GetInvestorDocuments(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorDocumentsParams)

	// (GET /investors/{id}/documents/{documentId}/{fileName})
	GetInvestorDocument(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, documentId openapi_types.UUID, fileName string)
	// Get email addresses for an investor
	// (GET /investors/{id}/email-addresses)
	GetInvestorEmailAddresses(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Get the top assets held by market value for an investor
	// (GET /investors/{id}/fmca-top-assets)
	GetInvestorFmcaTopAssets(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorFmcaTopAssetsParams)
	// Get gains for all investments linked to an investor over a specified period
	// (GET /investors/{id}/gains)
	GetInvestorGains(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorGainsParams)
	// Get earliest inception date across all investments linked to an investor
	// (GET /investors/{id}/inception-date)
	GetInvestorInceptionDate(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Get paged investments linked an investor
	// (GET /investors/{id}/investments)
	GetPagedInvestorInvestments(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetPagedInvestorInvestmentsParams)
	// Get net return for an investor
	// (GET /investors/{id}/net-return)
	GetInvestorNetReturn(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorNetReturnParams)
	// Get pending transactions for an investor
	// (GET /investors/{id}/pending-transactions)
	GetInvestorPendingTransactions(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorPendingTransactionsParams)
	// Get phone numbers for an investor
	// (GET /investors/{id}/phone-numbers)
	GetInvestorPhoneNumbers(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Get the prescribed investor rate for an investor on a given date
	// (GET /investors/{id}/prescribed-investor-rate)
	GetInvestorPrescribedInvestorRate(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorPrescribedInvestorRateParams)
	// Get standing instructions for all investments linked to an investor
	// (GET /investors/{id}/standing-instructions)
	GetInvestorStandingInstructions(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)
	// Get total value and active investment count for an investor
	// (GET /investors/{id}/total-value)
	GetInvestorTotalValue(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorTotalValueParams)
	// Get paged transactions for an investor
	// (GET /investors/{id}/transactions)
	GetPagedInvestorTransactions(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetPagedInvestorTransactionsParams)
	// Get transaction balance breakdown for an investor over a specified period
	// (GET /investors/{id}/transactions/balance-breakdown)
	GetInvestorTransactionBalanceBreakdown(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorTransactionBalanceBreakdownParams)
	// Get transaction highlights for all investments linked to an investor over a specified period
	// (GET /investors/{id}/transactions/highlights)
	GetInvestorTransactionHighlights(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorTransactionHighlightsParams)
	// Get latest valid price date
	// (GET /latest-price-date)
	GetLatestPriceDate(w http.ResponseWriter, r *http.Request)
	// Get aggregate net return calculations for all accessible investments across successively longer periods
	// (GET /net-return-series)
	GetNetReturnSeries(w http.ResponseWriter, r *http.Request, params GetNetReturnSeriesParams)
	// Get pending transactions for all accessible investments over a specified period
	// (GET /pending-transactions)
	GetPendingTransactions(w http.ResponseWriter, r *http.Request, params GetPendingTransactionsParams)
	// Get standing instructions for all accessible investments
	// (GET /standing-instructions)
	GetStandingInstructions(w http.ResponseWriter, r *http.Request)
	// Get total value for all investments accessible to the user
	// (GET /total-value)
	GetTotalValue(w http.ResponseWriter, r *http.Request, params GetTotalValueParams)
	// Get total value of all accessible investments across multiple dates
	// (GET /total-value-series)
	GetTotalValueSeries(w http.ResponseWriter, r *http.Request, params GetTotalValueSeriesParams)
	// Get paged transactions relating to all investments accessible to the user within the specified date range
	// (GET /transactions)
	GetPagedTransactions(w http.ResponseWriter, r *http.Request, params GetPagedTransactionsParams)
	// Get transaction balance breakdown for all investments accessible to the user over a specified period
	// (GET /transactions/balance-breakdown)
	GetTransactionBalanceBreakdown(w http.ResponseWriter, r *http.Request, params GetTransactionBalanceBreakdownParams)
	// Get transaction highlights for all accessible investments over a specified period
	// (GET /transactions/highlights)
	GetTransactionHighlights(w http.ResponseWriter, r *http.Request, params GetTransactionHighlightsParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Get the top assets held by market value for all accessible investments
// (GET /fmca-top-assets)
func (_ Unimplemented) GetFmcaTopAssets(w http.ResponseWriter, r *http.Request, params GetFmcaTopAssetsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get the risk for a fund for the current date
// (GET /funds/{code}/risk)
func (_ Unimplemented) GetFundRisk(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get all unit prices for a fund for a given date range
// (GET /funds/{code}/unit-price-series)
func (_ Unimplemented) GetFundUnitPriceSeries(w http.ResponseWriter, r *http.Request, code string, params GetFundUnitPriceSeriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get the volatility for a fund for the current date
// (GET /funds/{code}/volatility)
func (_ Unimplemented) GetFundVolatility(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get gains for all accessible investments over a specified period
// (GET /gains)
func (_ Unimplemented) GetGains(w http.ResponseWriter, r *http.Request, params GetGainsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get earliest inception date across all accessible investments
// (GET /inception-date)
func (_ Unimplemented) GetInceptionDate(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get paged investments
// (GET /investments)
func (_ Unimplemented) GetPagedInvestments(w http.ResponseWriter, r *http.Request, params GetPagedInvestmentsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /investments/documents)
func (_ Unimplemented) GetInvestmentsDocuments(w http.ResponseWriter, r *http.Request, params GetInvestmentsDocumentsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get paged list of total value for all accessible investments
// (GET /investments/total-values)
func (_ Unimplemented) GetPagedInvestmentTotalValues(w http.ResponseWriter, r *http.Request, params GetPagedInvestmentTotalValuesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a single investment
// (GET /investments/{id})
func (_ Unimplemented) GetInvestment(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get the bank accounts for a single investment
// (GET /investments/{id}/bank-accounts)
func (_ Unimplemented) GetInvestmentBankAccounts(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /investments/{id}/documents)
func (_ Unimplemented) GetInvestmentDocuments(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentDocumentsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /investments/{id}/documents/{documentId}/{fileName})
func (_ Unimplemented) GetInvestmentDocument(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, documentId openapi_types.UUID, fileName string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get the FMCA investment mix for an investment
// (GET /investments/{id}/fmca-investment-mix)
func (_ Unimplemented) GetFmcaInvestmentMix(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetFmcaInvestmentMixParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get the top assets held by market value for an investment
// (GET /investments/{id}/fmca-top-assets)
func (_ Unimplemented) GetInvestmentFmcaTopAssets(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentFmcaTopAssetsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get units and price per fund for an investment on a given date
// (GET /investments/{id}/funds)
func (_ Unimplemented) GetInvestmentFunds(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentFundsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get investment gains for an investment over a specified period
// (GET /investments/{id}/gains)
func (_ Unimplemented) GetInvestmentGains(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentGainsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get investors linked an investment
// (GET /investments/{id}/investors)
func (_ Unimplemented) GetInvestmentInvestors(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get net return for an investment
// (GET /investments/{id}/net-return)
func (_ Unimplemented) GetInvestmentNetReturn(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentNetReturnParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get net return calculations for an investment across successively longer periods
// (GET /investments/{id}/net-return-series)
func (_ Unimplemented) GetInvestmentNetReturnSeries(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentNetReturnSeriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get paged pending transactions for an investment
// (GET /investments/{id}/pending-transactions)
func (_ Unimplemented) GetInvestmentPendingTransactions(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentPendingTransactionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get prescribed investor rate for an investment on a given date
// (GET /investments/{id}/prescribed-investor-rate)
func (_ Unimplemented) GetInvestmentPrescribedInvestorRate(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentPrescribedInvestorRateParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get  min and max price dates for all funds
// (GET /investments/{id}/price-dates)
func (_ Unimplemented) GetInvestmentsFundsPriceDates(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get standing instructions for an investment
// (GET /investments/{id}/standing-instructions)
func (_ Unimplemented) GetInvestmentStandingInstructions(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get investment target fund allocation
// (GET /investments/{id}/target-fund-allocation)
func (_ Unimplemented) GetInvestmentTargetFundAllocation(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get total value and active investment count for an investor
// (GET /investments/{id}/total-value)
func (_ Unimplemented) GetInvestmentTotalValue(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentTotalValueParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get total value of an investment across multiple dates
// (GET /investments/{id}/total-value-series)
func (_ Unimplemented) GetInvestmentTotalValueSeries(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentTotalValueSeriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get paged transactions for an investment
// (GET /investments/{id}/transactions)
func (_ Unimplemented) GetPagedInvestmentTransactions(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetPagedInvestmentTransactionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get transaction balance breakdown for an investment over a specified period
// (GET /investments/{id}/transactions/balance-breakdown)
func (_ Unimplemented) GetInvestmentTransactionBalanceBreakdown(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentTransactionBalanceBreakdownParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get transactions for an investment in csv format
// (GET /investments/{id}/transactions/csv)
func (_ Unimplemented) GetInvestmentTransactionsCsv(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentTransactionsCsvParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get transaction highlights for an investment over a specified period
// (GET /investments/{id}/transactions/highlights)
func (_ Unimplemented) GetInvestmentTransactionHighlights(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestmentTransactionHighlightsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get paged investors
// (GET /investors)
func (_ Unimplemented) GetPagedInvestors(w http.ResponseWriter, r *http.Request, params GetPagedInvestorsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /investors/documents)
func (_ Unimplemented) GetInvestorsDocuments(w http.ResponseWriter, r *http.Request, params GetInvestorsDocumentsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get paged total value and active investment count for all accessible investors
// (GET /investors/total-values)
func (_ Unimplemented) GetPagedInvestorTotalValues(w http.ResponseWriter, r *http.Request, params GetPagedInvestorTotalValuesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a single investor
// (GET /investors/{id})
func (_ Unimplemented) GetInvestor(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get addresses linked an investor
// (GET /investors/{id}/addresses)
func (_ Unimplemented) GetInvestorAddresses(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /investors/{id}/documents)
func (_ Unimplemented) GetInvestorDocuments(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorDocumentsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /investors/{id}/documents/{documentId}/{fileName})
func (_ Unimplemented) GetInvestorDocument(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, documentId openapi_types.UUID, fileName string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get email addresses for an investor
// (GET /investors/{id}/email-addresses)
func (_ Unimplemented) GetInvestorEmailAddresses(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get the top assets held by market value for an investor
// (GET /investors/{id}/fmca-top-assets)
func (_ Unimplemented) GetInvestorFmcaTopAssets(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorFmcaTopAssetsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get gains for all investments linked to an investor over a specified period
// (GET /investors/{id}/gains)
func (_ Unimplemented) GetInvestorGains(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorGainsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get earliest inception date across all investments linked to an investor
// (GET /investors/{id}/inception-date)
func (_ Unimplemented) GetInvestorInceptionDate(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get paged investments linked an investor
// (GET /investors/{id}/investments)
func (_ Unimplemented) GetPagedInvestorInvestments(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetPagedInvestorInvestmentsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get net return for an investor
// (GET /investors/{id}/net-return)
func (_ Unimplemented) GetInvestorNetReturn(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorNetReturnParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get pending transactions for an investor
// (GET /investors/{id}/pending-transactions)
func (_ Unimplemented) GetInvestorPendingTransactions(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorPendingTransactionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get phone numbers for an investor
// (GET /investors/{id}/phone-numbers)
func (_ Unimplemented) GetInvestorPhoneNumbers(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get the prescribed investor rate for an investor on a given date
// (GET /investors/{id}/prescribed-investor-rate)
func (_ Unimplemented) GetInvestorPrescribedInvestorRate(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorPrescribedInvestorRateParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get standing instructions for all investments linked to an investor
// (GET /investors/{id}/standing-instructions)
func (_ Unimplemented) GetInvestorStandingInstructions(w http.ResponseWriter, r *http.Request, id openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get total value and active investment count for an investor
// (GET /investors/{id}/total-value)
func (_ Unimplemented) GetInvestorTotalValue(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorTotalValueParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get paged transactions for an investor
// (GET /investors/{id}/transactions)
func (_ Unimplemented) GetPagedInvestorTransactions(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetPagedInvestorTransactionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get transaction balance breakdown for an investor over a specified period
// (GET /investors/{id}/transactions/balance-breakdown)
func (_ Unimplemented) GetInvestorTransactionBalanceBreakdown(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorTransactionBalanceBreakdownParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get transaction highlights for all investments linked to an investor over a specified period
// (GET /investors/{id}/transactions/highlights)
func (_ Unimplemented) GetInvestorTransactionHighlights(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvestorTransactionHighlightsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get latest valid price date
// (GET /latest-price-date)
func (_ Unimplemented) GetLatestPriceDate(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get aggregate net return calculations for all accessible investments across successively longer periods
// (GET /net-return-series)
func (_ Unimplemented) GetNetReturnSeries(w http.ResponseWriter, r *http.Request, params GetNetReturnSeriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get pending transactions for all accessible investments over a specified period
// (GET /pending-transactions)
func (_ Unimplemented) GetPendingTransactions(w http.ResponseWriter, r *http.Request, params GetPendingTransactionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get standing instructions for all accessible investments
// (GET /standing-instructions)
func (_ Unimplemented) GetStandingInstructions(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get total value for all investments accessible to the user
// (GET /total-value)
func (_ Unimplemented) GetTotalValue(w http.ResponseWriter, r *http.Request, params GetTotalValueParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get total value of all accessible investments across multiple dates
// (GET /total-value-series)
func (_ Unimplemented) GetTotalValueSeries(w http.ResponseWriter, r *http.Request, params GetTotalValueSeriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get paged transactions relating to all investments accessible to the user within the specified date range
// (GET /transactions)
func (_ Unimplemented) GetPagedTransactions(w http.ResponseWriter, r *http.Request, params GetPagedTransactionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get transaction balance breakdown for all investments accessible to the user over a specified period
// (GET /transactions/balance-breakdown)
func (_ Unimplemented) GetTransactionBalanceBreakdown(w http.ResponseWriter, r *http.Request, params GetTransactionBalanceBreakdownParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get transaction highlights for all accessible investments over a specified period
// (GET /transactions/highlights)
func (_ Unimplemented) GetTransactionHighlights(w http.ResponseWriter, r *http.Request, params GetTransactionHighlightsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetFmcaTopAssets operation middleware
func (siw *ServerInterfaceWrapper) GetFmcaTopAssets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFmcaTopAssetsParams

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "includeNegativeAssets" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeNegativeAssets", r.URL.Query(), &params.IncludeNegativeAssets)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeNegativeAssets", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFmcaTopAssets(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetFundRisk operation middleware
func (siw *ServerInterfaceWrapper) GetFundRisk(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFundRisk(w, r, code)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetFundUnitPriceSeries operation middleware
func (siw *ServerInterfaceWrapper) GetFundUnitPriceSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFundUnitPriceSeriesParams

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", r.URL.Query(), &params.StartDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "startDate", Err: err})
		return
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", r.URL.Query(), &params.EndDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "endDate", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFundUnitPriceSeries(w, r, code, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetFundVolatility operation middleware
func (siw *ServerInterfaceWrapper) GetFundVolatility(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFundVolatility(w, r, code)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetGains operation middleware
func (siw *ServerInterfaceWrapper) GetGains(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGainsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGains(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInceptionDate operation middleware
func (siw *ServerInterfaceWrapper) GetInceptionDate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInceptionDate(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPagedInvestments operation middleware
func (siw *ServerInterfaceWrapper) GetPagedInvestments(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPagedInvestmentsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "after", Err: err})
		return
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", r.URL.Query(), &params.Before)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "before", Err: err})
		return
	}

	// ------------- Optional query parameter "investmentCode" -------------

	err = runtime.BindQueryParameter("form", true, false, "investmentCode", r.URL.Query(), &params.InvestmentCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "investmentCode", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPagedInvestments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentsDocuments operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentsDocuments(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentsDocumentsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentsDocuments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPagedInvestmentTotalValues operation middleware
func (siw *ServerInterfaceWrapper) GetPagedInvestmentTotalValues(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPagedInvestmentTotalValuesParams

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "after", Err: err})
		return
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", r.URL.Query(), &params.Before)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "before", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPagedInvestmentTotalValues(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestment operation middleware
func (siw *ServerInterfaceWrapper) GetInvestment(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestment(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentBankAccounts operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentBankAccounts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentBankAccounts(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentDocuments operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentDocuments(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentDocumentsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentDocuments(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentDocument operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentDocument(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "documentId" -------------
	var documentId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "documentId", runtime.ParamLocationPath, chi.URLParam(r, "documentId"), &documentId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "fileName" -------------
	var fileName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "fileName", runtime.ParamLocationPath, chi.URLParam(r, "fileName"), &fileName)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fileName", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentDocument(w, r, id, documentId, fileName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetFmcaInvestmentMix operation middleware
func (siw *ServerInterfaceWrapper) GetFmcaInvestmentMix(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFmcaInvestmentMixParams

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFmcaInvestmentMix(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentFmcaTopAssets operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentFmcaTopAssets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentFmcaTopAssetsParams

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "includeNegativeAssets" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeNegativeAssets", r.URL.Query(), &params.IncludeNegativeAssets)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeNegativeAssets", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentFmcaTopAssets(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentFunds operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentFunds(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentFundsParams

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentFunds(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentGains operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentGains(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentGainsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentGains(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentInvestors operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentInvestors(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentInvestors(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentNetReturn operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentNetReturn(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentNetReturnParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentNetReturn(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentNetReturnSeries operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentNetReturnSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentNetReturnSeriesParams

	// ------------- Optional query parameter "dates" -------------

	err = runtime.BindQueryParameter("form", true, false, "dates", r.URL.Query(), &params.Dates)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "dates", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentNetReturnSeries(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentPendingTransactions operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentPendingTransactions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentPendingTransactionsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentPendingTransactions(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentPrescribedInvestorRate operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentPrescribedInvestorRate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentPrescribedInvestorRateParams

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentPrescribedInvestorRate(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentsFundsPriceDates operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentsFundsPriceDates(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentsFundsPriceDates(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentStandingInstructions operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentStandingInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentStandingInstructions(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentTargetFundAllocation operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentTargetFundAllocation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentTargetFundAllocation(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentTotalValue operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentTotalValue(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentTotalValueParams

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentTotalValue(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentTotalValueSeries operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentTotalValueSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentTotalValueSeriesParams

	// ------------- Optional query parameter "dates" -------------

	err = runtime.BindQueryParameter("form", true, false, "dates", r.URL.Query(), &params.Dates)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "dates", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentTotalValueSeries(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPagedInvestmentTransactions operation middleware
func (siw *ServerInterfaceWrapper) GetPagedInvestmentTransactions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPagedInvestmentTransactionsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPagedInvestmentTransactions(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentTransactionBalanceBreakdown operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentTransactionBalanceBreakdown(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentTransactionBalanceBreakdownParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	// ------------- Optional query parameter "groupingType" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupingType", r.URL.Query(), &params.GroupingType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupingType", Err: err})
		return
	}

	// ------------- Optional query parameter "groupByFund" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupByFund", r.URL.Query(), &params.GroupByFund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupByFund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentTransactionBalanceBreakdown(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentTransactionsCsv operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentTransactionsCsv(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentTransactionsCsvParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentTransactionsCsv(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestmentTransactionHighlights operation middleware
func (siw *ServerInterfaceWrapper) GetInvestmentTransactionHighlights(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestmentTransactionHighlightsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestmentTransactionHighlights(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPagedInvestors operation middleware
func (siw *ServerInterfaceWrapper) GetPagedInvestors(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPagedInvestorsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "after", Err: err})
		return
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", r.URL.Query(), &params.Before)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "before", Err: err})
		return
	}

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "InvestorCode" -------------

	err = runtime.BindQueryParameter("form", true, false, "InvestorCode", r.URL.Query(), &params.InvestorCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "InvestorCode", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPagedInvestors(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorsDocuments operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorsDocuments(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestorsDocumentsParams

	// ------------- Optional query parameter "includeInvestmentDocuments" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeInvestmentDocuments", r.URL.Query(), &params.IncludeInvestmentDocuments)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeInvestmentDocuments", Err: err})
		return
	}

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorsDocuments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPagedInvestorTotalValues operation middleware
func (siw *ServerInterfaceWrapper) GetPagedInvestorTotalValues(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPagedInvestorTotalValuesParams

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "after", Err: err})
		return
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", r.URL.Query(), &params.Before)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "before", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPagedInvestorTotalValues(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestor operation middleware
func (siw *ServerInterfaceWrapper) GetInvestor(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestor(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorAddresses operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorAddresses(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorAddresses(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorDocuments operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorDocuments(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestorDocumentsParams

	// ------------- Optional query parameter "includeInvestmentDocuments" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeInvestmentDocuments", r.URL.Query(), &params.IncludeInvestmentDocuments)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeInvestmentDocuments", Err: err})
		return
	}

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorDocuments(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorDocument operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorDocument(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "documentId" -------------
	var documentId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "documentId", runtime.ParamLocationPath, chi.URLParam(r, "documentId"), &documentId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "fileName" -------------
	var fileName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "fileName", runtime.ParamLocationPath, chi.URLParam(r, "fileName"), &fileName)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fileName", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorDocument(w, r, id, documentId, fileName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorEmailAddresses operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorEmailAddresses(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorEmailAddresses(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorFmcaTopAssets operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorFmcaTopAssets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestorFmcaTopAssetsParams

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "includeNegativeAssets" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeNegativeAssets", r.URL.Query(), &params.IncludeNegativeAssets)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeNegativeAssets", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorFmcaTopAssets(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorGains operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorGains(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestorGainsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorGains(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorInceptionDate operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorInceptionDate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorInceptionDate(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPagedInvestorInvestments operation middleware
func (siw *ServerInterfaceWrapper) GetPagedInvestorInvestments(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPagedInvestorInvestmentsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "after", Err: err})
		return
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", r.URL.Query(), &params.Before)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "before", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPagedInvestorInvestments(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorNetReturn operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorNetReturn(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestorNetReturnParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorNetReturn(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorPendingTransactions operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorPendingTransactions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestorPendingTransactionsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorPendingTransactions(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorPhoneNumbers operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorPhoneNumbers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorPhoneNumbers(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorPrescribedInvestorRate operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorPrescribedInvestorRate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestorPrescribedInvestorRateParams

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorPrescribedInvestorRate(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorStandingInstructions operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorStandingInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorStandingInstructions(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorTotalValue operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorTotalValue(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestorTotalValueParams

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorTotalValue(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPagedInvestorTransactions operation middleware
func (siw *ServerInterfaceWrapper) GetPagedInvestorTransactions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPagedInvestorTransactionsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPagedInvestorTransactions(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorTransactionBalanceBreakdown operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorTransactionBalanceBreakdown(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestorTransactionBalanceBreakdownParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	// ------------- Optional query parameter "groupingType" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupingType", r.URL.Query(), &params.GroupingType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupingType", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorTransactionBalanceBreakdown(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInvestorTransactionHighlights operation middleware
func (siw *ServerInterfaceWrapper) GetInvestorTransactionHighlights(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvestorTransactionHighlightsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvestorTransactionHighlights(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLatestPriceDate operation middleware
func (siw *ServerInterfaceWrapper) GetLatestPriceDate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLatestPriceDate(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetNetReturnSeries operation middleware
func (siw *ServerInterfaceWrapper) GetNetReturnSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNetReturnSeriesParams

	// ------------- Optional query parameter "dates" -------------

	err = runtime.BindQueryParameter("form", true, false, "dates", r.URL.Query(), &params.Dates)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "dates", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNetReturnSeries(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPendingTransactions operation middleware
func (siw *ServerInterfaceWrapper) GetPendingTransactions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPendingTransactions(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetStandingInstructions operation middleware
func (siw *ServerInterfaceWrapper) GetStandingInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStandingInstructions(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTotalValue operation middleware
func (siw *ServerInterfaceWrapper) GetTotalValue(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTotalValueParams

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTotalValue(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTotalValueSeries operation middleware
func (siw *ServerInterfaceWrapper) GetTotalValueSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTotalValueSeriesParams

	// ------------- Optional query parameter "dates" -------------

	err = runtime.BindQueryParameter("form", true, false, "dates", r.URL.Query(), &params.Dates)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "dates", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTotalValueSeries(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPagedTransactions operation middleware
func (siw *ServerInterfaceWrapper) GetPagedTransactions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPagedTransactionsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPagedTransactions(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTransactionBalanceBreakdown operation middleware
func (siw *ServerInterfaceWrapper) GetTransactionBalanceBreakdown(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionBalanceBreakdownParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	// ------------- Optional query parameter "groupingType" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupingType", r.URL.Query(), &params.GroupingType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupingType", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTransactionBalanceBreakdown(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTransactionHighlights operation middleware
func (siw *ServerInterfaceWrapper) GetTransactionHighlights(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionHighlightsParams

	// ------------- Optional query parameter "fromDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromDate", r.URL.Query(), &params.FromDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toDate", r.URL.Query(), &params.ToDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toDate", Err: err})
		return
	}

	// ------------- Optional query parameter "fund" -------------

	err = runtime.BindQueryParameter("form", true, false, "fund", r.URL.Query(), &params.Fund)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fund", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTransactionHighlights(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/fmca-top-assets", wrapper.GetFmcaTopAssets)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/funds/{code}/risk", wrapper.GetFundRisk)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/funds/{code}/unit-price-series", wrapper.GetFundUnitPriceSeries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/funds/{code}/volatility", wrapper.GetFundVolatility)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/gains", wrapper.GetGains)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inception-date", wrapper.GetInceptionDate)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments", wrapper.GetPagedInvestments)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/documents", wrapper.GetInvestmentsDocuments)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/total-values", wrapper.GetPagedInvestmentTotalValues)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}", wrapper.GetInvestment)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/bank-accounts", wrapper.GetInvestmentBankAccounts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/documents", wrapper.GetInvestmentDocuments)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/documents/{documentId}/{fileName}", wrapper.GetInvestmentDocument)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/fmca-investment-mix", wrapper.GetFmcaInvestmentMix)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/fmca-top-assets", wrapper.GetInvestmentFmcaTopAssets)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/funds", wrapper.GetInvestmentFunds)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/gains", wrapper.GetInvestmentGains)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/investors", wrapper.GetInvestmentInvestors)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/net-return", wrapper.GetInvestmentNetReturn)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/net-return-series", wrapper.GetInvestmentNetReturnSeries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/pending-transactions", wrapper.GetInvestmentPendingTransactions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/prescribed-investor-rate", wrapper.GetInvestmentPrescribedInvestorRate)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/price-dates", wrapper.GetInvestmentsFundsPriceDates)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/standing-instructions", wrapper.GetInvestmentStandingInstructions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/target-fund-allocation", wrapper.GetInvestmentTargetFundAllocation)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/total-value", wrapper.GetInvestmentTotalValue)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/total-value-series", wrapper.GetInvestmentTotalValueSeries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/transactions", wrapper.GetPagedInvestmentTransactions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/transactions/balance-breakdown", wrapper.GetInvestmentTransactionBalanceBreakdown)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/transactions/csv", wrapper.GetInvestmentTransactionsCsv)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investments/{id}/transactions/highlights", wrapper.GetInvestmentTransactionHighlights)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors", wrapper.GetPagedInvestors)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/documents", wrapper.GetInvestorsDocuments)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/total-values", wrapper.GetPagedInvestorTotalValues)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}", wrapper.GetInvestor)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/addresses", wrapper.GetInvestorAddresses)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/documents", wrapper.GetInvestorDocuments)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/documents/{documentId}/{fileName}", wrapper.GetInvestorDocument)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/email-addresses", wrapper.GetInvestorEmailAddresses)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/fmca-top-assets", wrapper.GetInvestorFmcaTopAssets)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/gains", wrapper.GetInvestorGains)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/inception-date", wrapper.GetInvestorInceptionDate)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/investments", wrapper.GetPagedInvestorInvestments)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/net-return", wrapper.GetInvestorNetReturn)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/pending-transactions", wrapper.GetInvestorPendingTransactions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/phone-numbers", wrapper.GetInvestorPhoneNumbers)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/prescribed-investor-rate", wrapper.GetInvestorPrescribedInvestorRate)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/standing-instructions", wrapper.GetInvestorStandingInstructions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/total-value", wrapper.GetInvestorTotalValue)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/transactions", wrapper.GetPagedInvestorTransactions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/transactions/balance-breakdown", wrapper.GetInvestorTransactionBalanceBreakdown)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/investors/{id}/transactions/highlights", wrapper.GetInvestorTransactionHighlights)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/latest-price-date", wrapper.GetLatestPriceDate)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/net-return-series", wrapper.GetNetReturnSeries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/pending-transactions", wrapper.GetPendingTransactions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/standing-instructions", wrapper.GetStandingInstructions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/total-value", wrapper.GetTotalValue)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/total-value-series", wrapper.GetTotalValueSeries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/transactions", wrapper.GetPagedTransactions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/transactions/balance-breakdown", wrapper.GetTransactionBalanceBreakdown)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/transactions/highlights", wrapper.GetTransactionHighlights)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9W3PbOLLwX0Hp+x7OqZIv2Umdh7zluuvanYwr8c48nNkHiGxJ2FCABgBta1P576cA",
	"8CqCJABStOzhUxybaNy6G33v74uI7faMApVi8eb7QkRb2GH949s45iAEiC8g9owKUL/EcUwkYRQnt5zt",
	"gUsCYvFmjRMBy8W+8qvvCyJhV//h/3NYL94s/t9VOedVNuHVDb0HIRnPZl38WC5omiR4lcDijeQpLBfy",
	"sIfFmwXmHB8WP34Uv2Crf0Mk1Yh3OME0gncc8LeYPdBJVt426Y2E3bjb0BD9toJ3LKVS/bRmfIfl4s0i",
	"ZqlaTTEvTXcr4GreGETEyV6BViNaFi4kJ3Sjvl+nNH7PYnD42LbNDyxKd2BW57GlOBv2AUuobwxLuJBk",
	"V9lbudZ81E1cG5OmJLZ9viYJfMY7cDoHonG3HbojAMYDhycsws6XtgOJYyxx8+POS5qGCxQoEUQ3H3eY",
	"JE/DtqpThy3+0y7CNwUi/UweA9e/3kXYjzT8dty6znB+1w3Sf/tvhQD5PsFCjM3Glos98AioxBtwZKoC",
	"Isn4rzhJ4R0WbqPaDumO7fXexBnjRmONw/DCDs7zEVQAnLl5CAblQ+70Xxxxrn6ujU+6z6t8NPTEfvjl",
	"jcbW20lpfMtJBAqjpuG29ikHIFg7PE/C8mEhO/xIdunOjxB3hPoOatvxFyK+hTIQDn+kQKODG5Jz5rlL",
	"r3PkRHxzRHfJxji4X1mCJUmIPLyE4/M7k+Xivth9MMv4KyY0lFPcKw5nn7llq10ruaERaEVHnUHgiuKB",
	"KFWKPJ4TRwkT0Hl5vZcfuWJJTNTPq1Qt7WeQWxa74S7Al8YCHe9ruSBuShqpXqIHK8VCAn+fkOzkh6hM",
	"ywV1lSv2nOwwP9x06nqNUUJimbpJIdJN+OhGxXeYfnsbRbnVwEfKMqM+m1sMu/hVObuzvKbG5EwvZEqO",
	"abQdAICIW3OzFSluxVgCmOoLTNdr8hgI+2EL9D0HLCH+p4xCyd35xqfUmY+RLUiAK0H9jSWx2qwnJ3Vl",
	"gz5UHoViUkqJscIGPa6Ns5j6NvMrGHiTOYOc1oDzASQmydC13zGJE62LhS6+x5RokeLyGUeUjfI1iFu8",
	"gXhiNHLRffd4kxF7F8xb81XfJstLe4rtWlBmwgNg3FeFIVy4v83OgpxZi7PukmCPRXjLez4yF5EJTCOd",
	"lb4xT7nMjPoHofDKaaWVAX/xHfCT74DXTgOiTOt00GtSKrnbtz2C254JiRN3awRsXF0wCr+G4kL2Xvl6",
	"A5OPVBJ5cLZTKinzl/U7wuU2XNn04xkboLFRIPo/5QAy44NPxosIj0ud54k5V6emuiNx7OHVdBZ5z5Vd",
	"1nxyfoQCR0OH8pJUQJhzt2t/t1tGoUQ9L7VnPC5ZX8SA7YwoO79vD3roV+f97DMnk78Zn1z6Znxa0fMJ",
	"JW8ruk2y+X9gCUIWXqcnsj1/BvkFZMpDQ6RoPj7YXFGs4CtwAiLA6QY0/uAmSC371tvLFYTEXH4IF9uO",
	"djsJpttOOMi+cVsgvY+suZaOItEK1oy7+qwkTmpXSKj86S8lxhEqYdOGcrdAY0I3dxxTgSO1jxNF1vWi",
	"kxnsLIXDeg2RJPdwQneg+ni0iDcHimhexjRU0YMEYQRSCkHTWi2rImDYyrmO+VxBnIP8Ev4o8VaPn8N7",
	"8FVifTE3VEienpI6h1JjxUl1hP3tU0Q4ARpj/qkaAeAxzj16yYfmva3NSnv9knr6Wyk8+g8STXRwPmzL",
	"2LtwddKCmNMQeR9FBBH814OQsLu8+eXyq+SAfekqwvQLYH0RHHD8C00OR3NXdMMI068A35w/viM7YKl0",
	"/v43TgxK9X+dAN0cmbAIlf/zerFsG1xIEtoSSPL46sbw5ucKYGUrvaLKcvGgNuIzxHazd5hvQH5Kafw2",
	"ySPCJ8HTronDEbUX6gkj9LxkoRFCKUtdNFgZil01oRMYLI6XPw3W2c4sDNNKUfBvZLNNyGYbHAkRYbH9",
	"UAmZEq7vPKN9Y3qVijVA6FAORhSA2GHxvdAkDo53IXIbc/yAEzEedo6j7kURT5WUHLEdDNL6AgcrzBow",
	"9H0CmGdafAAI39SwUI0VQs9WDUkTLCGu3PeH0yW0nVZhXi72+KAt2cOubUg0UjgVS/z4BVbh4Z+yvMH3",
	"jEp4dHN+VYY5qwqVMR7RrbLKUrBwxK7KqK8s5RF4j0pX0lVJrQxzVmw74s+G8d0JPRmj2nX+SYmx1J9e",
	"LEvzqUY7/6PFT3L6tgMLOPkfmmOumT7BKg+vhm0tCnfy0W/vgQvz9avLazU92wPFe7J4s/jp8vry1UJx",
	"V7nVm7la7yJ8Idn+QieJ6d9tQDYnNpZ0gTBKiJCIrZHcAjKD0MOWRFsUMSokkakE/beNjtsVEokt5pCP",
	"2Gaxmer/OElQ+TAIhKMIhCCrBJBk+utUAL9c6B1wnDO2xV9B1lLj9IY43oEELhZv/vd47eoNRoxmy5QM",
	"cZCcwD3UVrRQZ754s/gjBX5Y5P5/g8HLrDCAu8upcXFrtOfsnsQQLxEH9WEkRXmI5lgly490C0mMVgf9",
	"gdhDRNYEYqTe3JZ1Zn8q19m7pLstoCwXCxlC0pdi5jenlHJ6iT7AGqeJ+d2r68uW+ROyI9J+UO1a/PGS",
	"ftsCRZpGCtQicosworDBSpxCOg0GKYQiNErSGGJEqD4lnhF4fcGaqNvWnIH4nAEvsKlxiIUl5ce/lLJg",
	"JtLE8pfraxNRQGWeyLLfJ8To61f/zt7GEqB3+qjhD/AoxwW2TzAZAdqxaLz45e+K47y+ftVkIf+kOJVb",
	"xsl/IDYf/dT86BPjKxLHQPVSRbozoReK5vUtS7Y/JpEd5t9AZpixZlzzlQovIXWeiTeKR1R5ptrc4l9q",
	"viudl3r1PWIx/LjKE+w6GaJGPSK+mZlzCm0yrCzxsI9Xqe80KDuzymfKEVox8hKfdTi/QtA/UsIhzp+b",
	"dp5wUmw+TrUMReRWOL443ATUir7XzQt/h2P0Bf5IQcjTovgRNukf1e+jlHOgEmUvUo7In3QqtQV9lUh1",
	"oTWgC6HFkf7HPUmQGoX0KFHMXH+A0H9pplyouHpB4r8zjFWsOUMaRXyMIsF25hvNzDNuXYLUf+GYbuCy",
	"jXCOxKoBNFTZ3Ugk1HjDvkrMzSXpNZQzInMLl+hmjSiTFXlAHUh5DEi9UupkHkiSIB15gdac7fRngHlC",
	"lFRlQOY3pO6l7ZUrYzeGizEfaTze1oDGCBucT4yo6L6pPPjFe0unZHltKkcg5+sF58kA2+GdHR+0caIK",
	"O8RoQ+6BVjDLhSHWM7h7X/Xyc4e3vcyNH/jC12d9Ju+8pTLAgNe+C1rAm28Fd5YvvxXjfN7/DSa0/5nX",
	"LrCKWIz0sEJ07lfJgx5yXfygjziOHk9tR9CLi3ASpYkp89WiAOflIkZ+5XzWkNWUGL4CzSQUmfsfQ58d",
	"4JS8oF7gIpAFtADxpPxjKGdH8HWis+uriN2D4gMlke2BExZXyN+QlSH/oiDERW537X3kiiF1hI9wkhC6",
	"MdS+wgJiJcnXBNDMboY4RIzHCN9joo2cCEecCdGxq0tUWhNfX79GZF1ylpiB0CLkFt8DwvTQAmOJGM8G",
	"Et52ehoGBXWGWxwXlj4re6pVRFmckEbspVcCaaUHmCfNtEE7pZVHffG6+cVnJtEnpnhZk3IKFDxC3l7E",
	"s5t/CuIpf9NvBd/jDcSFLdzBiq1UI4xEuhI6AlJqCAgeiVDIrD77/fffTdS4+gFlboiDUZVWgPZsbxy8",
	"Gag9h3vCUmEHZILK+yDZCEH7quoehc4n225GNq4MxWOwRDt8UPMag7LaQNVCKyvj2Rq9ur6+vkRvEQeR",
	"JplZXNsb1vAAHGk3jIJ6LH1o+zMihnlgtEkxx1QCmBVozkXj3AsRY4nRFgu0AqCIA462all3DMVqmztC",
	"QTEXTJncAq+fcLSFKLfPHJ0040eXaGyS7NhArf72rhxGaKxYCYiWW0WYxkeAq0PsOHVSO33Nm6H2pifO",
	"7zdHtA2h5ur0QyNhh/QGkNwSgRgFfeB65JrxB8xjsUQHlqIIUyS0SExEdoQZnrSQCKvRQ3nOdwpAgbwK",
	"OXapTHGSHBA8RkkqyD2UKzQXWX7fdoIms8PLJuRyXgo966eVLah5XCscfXM+LxsnGOfAzG32nleW3zLs",
	"wKocNudja5JI4KCdABVtRonN7R6fMkcyhieTk1tLjASLAX3wvCWBVoBnJ0ibpzjgmb/Ki2JXH3yLYFgM",
	"KIpBN9/E0TXSMdXLU6Jys0B2IA53APJEXhukBtZ+TbWcZiZpYEt5002s0eaTC81n/SVF48OUOMllgzVS",
	"0keVfzUFyKo2tkRY5FZzLfXmfNJBlitjhp2kukIjzCyVR0vP2XBuk4BWY/1IMRSzpDlLmrOkOUuaQyTN",
	"iaS6tsoOw+W7Xsjhkl476DOV+YpHtfIqOQcA/azDhkwmUPOR/07iH04G1PJdKIcvM8ytLKt8tI8cJor5",
	"m5+KV6L4osVQWVQKtEuhdV+hDq9v9xT2Za5PQy/D6WIE/D8/QydGgtBNDYOddRuFwFcrTL9dZIWJhRM6",
	"qxEY5UMsEUDlHD3YWa2r+3Iw1VoteDD2dkMNxugWsGeG5Tna1bFuMO57Kvd9uv2ouLqcDQZ/IoNBHR2v",
	"vpe92H5cfc87rf3wQ9MpsbQOtNJJbnzgRd+5c4luatSLCETWdjieuGoBNDaq6pyg8rcXO1O/3zEvyKSz",
	"RIn6V6CUxsCTA6GbIqSzLbmlIT/XAvsx1cEPWamBelIRuweuZP4iuUg9INqsZrqPtaYQ1bquTURSc27S",
	"xPGJrY0FB2TW9AAMyK5pgzh5hs2nn9+/rZqjd+TRCGS0VxSrJNLYmcoTJRoGajA9SYYzd5gzF+fMxTlz",
	"cczMxYE8Nu+q6cFZvSQyXSHBfKzksUqeVyUXqM3U2cdt9eKfjMvaMzKKV0SLn7W8sVG47TRGq0ZDpMEG",
	"q3aIwcYqC8hJadTgdnHPStmoJBxVCVO9yNUMJD+71OAcjTYaDcrKKBc852f0m9dOy4fmpI8Xn/RhT7qq",
	"MxfPlI8j9pL3b/CRA4oxrfleRWp3Qug3iPM/2kUFIyvsgQtGNRMzlEAYRSJVcARSeKt5rcJAHEkU634+",
	"oodHFZ0TXo5Dqdnub/Dj3AEy+HW2wZz0eS5xNEPBbllZ4UgLhVCQF7xohtDrEaUgM4Wy+/XNsk8CX9+i",
	"WUHAC1xZ4dM+w14LOe+3uMPqYd9lkyWeq0G02fskkON0APLkMzZIT/12B3iyj1hFG4cqab2XQ7lWbvFh",
	"VIVzpGEZLbmVcGVXbRVZJiDRtyhiux2+EKDmlpV4MF2QRhHkSssvsZI49E4171RiB2SsS/Twrkt0V815",
	"zarYmLjnEmLBBOEe+CET2JZmIn3QOra3MRiq/LOIdzCju0KpxYCQ0BfKysYpuNILLpStnX/BFTsm2PST",
	"TM4RxsdM7iE5oITRDfAMdYUPq9ubdjQXlXqtPppLNhxVhyMOavXqt6zDWKJVmjVOkoF2E0sjH5fkioKn",
	"KJVrL7URtV5SS599Ebkt6/BPLNrdlTWZxlvfWUl8p2RLXb2dAlmTE0hP9tQN80xjvq0U3yVt1QizjQsV",
	"baAucj3zgruW0NiSzdYUL8uBFMoqUkDQChR/zBgSpoeKLhsTDpFUHNTBrhLoWLH3uHoSka0lq6z15HJp",
	"KffHjJxhdlIe0N1ZLJQNOEL15QR9YM8sZLgVYXx8NfZNd/AIEsGFkb/dBRTjXu1126AdoVpf2OHHzP+k",
	"Z+ohbaGdpkUz1WdvFlXbKXczRi25LmgBteSs4M6MONpwqUiNWmeedg+nZd5S7oJUusA51ZPNR6LqSCcR",
	"vQf3bX3pnjv+d/baC408doLpG4XcDXRSz4Adw4aKhFL3X7tQtHKBiw5s3py/HrYsUAyCbKi2VmVGKTMR",
	"EvuE6HG1IOZW2kAt0T86RTc3e0lWJuebgL1IpjhpmUtdM+ZEMNpDebbWdM+d8jq7BwZSnhtMT8rrAfoE",
	"PjktxGRYrANmcBUrPB6ZSmENJ8Wrll9L40ooaLVaULdmpbiEvZ6GMf3W6gqlVObBmwK9fX938+vHerVG",
	"mhwu0U2tVJEJAk2TBDGO/gOcoRVOMI2KYg1HJifMQReW0LP1pgCXKdvnpM89aZWQDnN3dV3P0t5tu/jx",
	"4ga6YAYHDliBTht8e8QmsDFhNii7JjHo0tvupQKqvMvHZ3dUCqg9uEDzqKrXzoj0BbNyZRNn7K8bi4eM",
	"5x579vyitTNtqETTC89XmmkHeH4V2uu0avWK7dJEkn2SkacnC/FzgdVLoOyZkEdemEn8YMcVxmYv2OwF",
	"a7aiHKfKpQNAX/bTAXFSGcUQ86g+rSqwq0znuFhxwN9i9tBvyNhwlu613iRxYrIoj1d3okSEyubemWW/",
	"K1btHxyZa1urCoyp4yJd1zCHRAYLbtFWh61lCcEs3at3L6+3WUVcpQFU4Fyiv5MH8hXfA8+SL5foi45F",
	"L/77M3nMfm6TOvMJdafhYeX6GqgitEUgp8bVwZhYIhZ3reXd4VPLcU6TD3pMt0M5fz88T8bfAfD85M4S",
	"fZvoEZRA4v18ROLeQSJ9//VXtCYJPKU8ahdF34v7WRr9c0ujz7KQz0nNYp3CJiIUReIeZVc2gHdsyWab",
	"kM3WoeZHU+ZUV8/JKtWgTBJ6zPEDTsQSSfy4RGsAYSKtYyLKTx15zVgM5m/lHv0l1PKAnjh9x2shzy2V",
	"1u+Un9RoZ8OrEXXnLqDh+rMV6lnLUhWMGFWIcsu9tTWQas/A7bO9WVNi5+r5c/X8uXr+XD1/yj5Nhh1Y",
	"ejRJVmFyD1vgJiJpTbjigBwlWEhdFkCYmgC5XAaYR1ukiL2tvbn+YuJlm98BNzKG34Jzjn0GHagYH7P/",
	"VDu0oOgBC7iz7j1l3uDuMgSMe3WdYty351QWnmSva91hDZwrUr+kitSM24v8KvQb1L6qwgsbHS76IvCe",
	"X5xdTcCem2fN4v8s/s/i/9w867QC6UlaZ7nADRVSn13bLK+AWFsrrbqk2xbapoSN4DZa6uE8RRU5Hdf7",
	"AkrHMf5B73UoWRxDCSSCAsx5d9CqRXW3a2jaiYXjmIMQXtm+xZjerJNOFH1bTP3McbXYyFAu3gHIE2Nt",
	"kCb1uzZwxJ5z0IOdXkaEc+htNRsmZsNEt2FirDZZ5Rxzk6w5tiagSVYvksIOk+QiREDQI8cSEz4qYC9G",
	"VqjvZijH64PmiVCt4CYVHY6xpz1jsUd6OLdmTD2IPjdimhsxzY2Y5kZMT9CIycJV7W2YCt46uL8LThK/",
	"AhbhYayMz11f5q4vc9eXE5vdXWi7wnGCWsAU/IfQCPSidK1CJ+N7MaROXxZWs8IC4txTWqTLZPIP4hAx",
	"HiN8j0mik1MySIQ3fQh6/1l5dRrvGaF5CqESN19fv0ZkXQm1YhzFDIzbeIvvQddRtQNdIsazwa0TGxgU",
	"1EFvcayh5VJcJ7+8yY/qw0Q1VE/rSqhsZrijrROYt2PBDu3M/AsFCRyRUFYOwoncHYpkVYi7/CAsdscs",
	"pBllblHJ0M26NW5h2eXoz4Nb9myfxbYYULaoiWWnB7wJqTdOp3qGT1UTaw60mQNt5kCbOdDmfANtNH8c",
	"McCmC15w7bjnFf9dD3YNe989e9PhzYbDRgkclQocvbJHWx3M4AZ2jM/t687dqOB3ynN/uj9Tf7oaj7K3",
	"bCo41KkbNvlbP8coGML4RG2cbPs/x9IhHuuc2zrNbZ2GiFC9DZ1q7Kkr7T7jUFtG4cKo3l6sSY3LVPaB",
	"kRm3CtTnbAXP3EhY3ctgdO+E5YvndmDT1m2s4UxwPMag/mOdzZB6a947txJjfG4kNjcSe2GNxHrpp+aW",
	"G9RKrCD2U/ZS8pWeO+l97rA0d1jq67Dk6eDql97mJjBeTWCqeel/1hYwU2Tbjd1vpRtiYBbeS+61UjKI",
	"U7ZJmNr6VK8wMTdPeFa2pm63pikhJWrlpep4FNXKESroS0QuM3/429tb9c9S/+e3D7+V//n08aP6p+2E",
	"+mqQzy0fnkfLB1+56UnaPQyMPp5bPcytHl5oq4e5vcLLa6/gFJrtyaqfvjz6pPkmc9H0uWj6XDT95RRN",
	"HymfxcI0je54seckAvdUlkzj1KMMoep4ZxMISuICsyOcJIr/pQIqWS2mhXolcbYjc+WLLVlFgztlokpn",
	"kso/9OZv1d4zPnMyejuaaiil9YLzpLF2eGfmgMrw1SBnibUV0lBcOaeJMjzUp8mwT5Sovf2AJptq92Hb",
	"u2/HySKcrK3zsF+TYMnQSq9J15PVS9HCgRJxIHubRU/QY5Z1llvP4qqDuIRYvPKK9g4ZyzKylDkJnQrR",
	"GAxVAaEoP2ZGT9O1eAoNbZL4z3F6FveCC40FPf+OxVbCr+CEaC/xmHMDzSSEKZVD7iE5oITRDfAMo0VH",
	"4OgUkaIt6x5qlZ9jQSeOBZ3DNl9O2GY7WQbpAVOGy3g0X2oJjpkDV55P4IodS7uxcUh4ik1hbpG3W8JR",
	"bIjYFf9x/m0JOuTY6rqepSBb3owRFW8kBJdG7Ibla4GyA3uySBF3wugMFKnQpo96XF0JW/tRaFUnNqpn",
	"ETnWTavjaMNjEfJ4yueLI9rBNuReeAOJ96wtx03S6tY0d2kiyT7JiKmb2p8mDgwb8h8j7muO93qW+uQc",
	"5DQoyMlf/+qjsB6J/eSBUePswi4wzAFSJ9Qw5limOZbpzxbL5Margix1Zx7XdBq2PEcxhS9jDjiaA44C",
	"Ao5G8y78+PF/AQAA//82LrVcAEIBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
